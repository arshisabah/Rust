<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="TermsProjectSettings">
    <currentTermsLanguage>en</currentTermsLanguage>
    <terms>
      <map>
        <entry key="en">
          <value>
            <map>
              <entry key="904933">
                <value>
                  <list>
                    <Term value="main function" definition="The main function is always the first code that runs in every executable Rust program. It has no parameters by default and returns nothing." />
                    <Term value="curly brackets" definition="In Rust, curly brackets `{}` are required around all function bodies." />
                    <Term value="curly bracket" definition="In Rust, curly brackets `{}` are required around all function bodies." />
                    <Term value="semicolon" definition="In Rust, a semicolon (`;`) marks the end of a statement and prepares for the next statement." />
                    <Term value="rustfmt" definition="Rustfmt is an automatic formatter tool under development to ensure a standard style across Rust projects." />
                  </list>
                </value>
              </entry>
              <entry key="904935">
                <value>
                  <list>
                    <Term value="immutable variable" definition="In Rust, an immutable variable is a variable that cannot be changed after its initial value is bound. By default, all variables in Rust are immutable." />
                    <Term value="immutable variables" definition="In Rust, an immutable variable is a variable that cannot be changed after its initial value is bound. By default, all variables in Rust are immutable." />
                  </list>
                </value>
              </entry>
              <entry key="904937">
                <value>
                  <list>
                    <Term value="Constants" definition="Constants are values bound to names that cannot change, declared using the `const` keyword with explicit type annotations. They are immutable by default and can only be set to constant expressions evaluated at compile time." />
                    <Term value="constants" definition="Constants are values bound to names that cannot change, declared using the `const` keyword with explicit type annotations. They are immutable by default and can only be set to constant expressions evaluated at compile time." />
                    <Term value="constant" definition="Constants are values bound to names that cannot change, declared using the `const` keyword with explicit type annotations. They are immutable by default and can only be set to constant expressions evaluated at compile time." />
                    <Term value="`const` keyword" definition="In Rust, the `const` keyword is used to declare constants, which are immutable by default and require explicit type annotations." />
                    <Term value="constant expression" definition="A constant expression in Rust is an expression that can be evaluated at compile time, used to initialize constants." />
                  </list>
                </value>
              </entry>
              <entry key="904938">
                <value>
                  <list>
                    <Term value="shadows" definition="In Rust, shadowing allows you to declare a new variable with the same name as a previous variable. The new variable shadows the previous one, meaning its value overrides the previous variable's value when the name is used." />
                    <Term value="shadowed" definition="In Rust, shadowing allows you to declare a new variable with the same name as a previous variable. The new variable shadows the previous one, meaning its value overrides the previous variable's value when the name is used." />
                    <Term value="shadow" definition="In Rust, shadowing allows you to declare a new variable with the same name as a previous variable. The new variable shadows the previous one, meaning its value overrides the previous variable's value when the name is used." />
                    <Term value="Shadowing" definition="In Rust, shadowing allows you to declare a new variable with the same name as a previous variable. The new variable shadows the previous one, meaning its value overrides the previous variable's value when the name is used." />
                    <Term value="shadowing" definition="In Rust, shadowing allows you to declare a new variable with the same name as a previous variable. The new variable shadows the previous one, meaning its value overrides the previous variable's value when the name is used." />
                  </list>
                </value>
              </entry>
              <entry key="904950">
                <value>
                  <list>
                    <Term value="snake case" definition="Snake case is the conventional style for function and variable names in Rust where all letters are lowercase and underscores separate words." />
                  </list>
                </value>
              </entry>
              <entry key="904951">
                <value>
                  <list>
                    <Term value="Statements" definition="In Rust, a statement is an instruction that performs an action and does not return a value. For example, `let y = 6;` is a statement." />
                    <Term value="statements" definition="In Rust, a statement is an instruction that performs an action and does not return a value. For example, `let y = 6;` is a statement." />
                    <Term value="statement" definition="In Rust, a statement is an instruction that performs an action and does not return a value. For example, `let y = 6;` is a statement." />
                    <Term value="Expressions" definition="In Rust, an expression evaluates to a resulting value. For instance, `5 + 6` evaluates to `11` and is considered an expression." />
                    <Term value="expression" definition="In Rust, an expression evaluates to a resulting value. For instance, `5 + 6` evaluates to `11` and is considered an expression." />
                    <Term value="expressions" definition="In Rust, an expression evaluates to a resulting value. For instance, `5 + 6` evaluates to `11` and is considered an expression." />
                    <Term value="block" definition="In Rust, a block is an expression enclosed in curly braces `{}` that often evaluates to a value. For example, `{ let x = 3; x + 1 }` evaluates to `4`." />
                  </list>
                </value>
              </entry>
              <entry key="904952">
                <value>
                  <list>
                    <Term value="Function" definition="A function is a block of organized, reusable code that is used to perform a single, related action." />
                    <Term value="function" definition="A function is a block of organized, reusable code that is used to perform a single, related action." />
                    <Term value="main function" definition="The main function serves as the entry point of a program where execution begins." />
                  </list>
                </value>
              </entry>
              <entry key="904953">
                <value>
                  <list>
                    <Term value="Type Annotation" definition="Specifying the type of a variable or parameter in programming to inform the compiler or interpreter what kind of data it will handle." />
                    <Term value="type annotations" definition="Specifying the type of a variable or parameter in programming to inform the compiler or interpreter what kind of data it will handle." />
                    <Term value="type annotation" definition="Specifying the type of a variable or parameter in programming to inform the compiler or interpreter what kind of data it will handle." />
                  </list>
                </value>
              </entry>
              <entry key="904956">
                <value>
                  <list>
                    <Term value="expressions" definition="Expressions return a value based on its operand." />
                    <Term value="statements" definition="Statements return a `()` type which behaves just like `void` in the C/C++ language." />
                    <Term value="()` type" definition="The `()` type in Rust behaves just like `void` in the C/C++ language." />
                  </list>
                </value>
              </entry>
              <entry key="904959">
                <value>
                  <list>
                    <Term value="if Expressions" definition="In Rust, an `if` expression allows code branching by providing a condition. If the condition is true, a specific block of code runs; otherwise, the code is skipped or an `else` block executes if provided." />
                    <Term value="if expressions" definition="In Rust, an `if` expression allows code branching by providing a condition. If the condition is true, a specific block of code runs; otherwise, the code is skipped or an `else` block executes if provided." />
                  </list>
                </value>
              </entry>
              <entry key="904960">
                <value>
                  <list>
                    <Term value="else if" definition="In Rust, 'else if' is used to handle multiple conditions, allowing the program to successively check each condition in a series." />
                    <Term value="match" definition="In Rust, 'match' is a powerful branching construct described in Chapter 6 of the Rust Programming Language Book, used for handling multiple conditions and improving code clarity compared to 'else if'." />
                  </list>
                </value>
              </entry>
              <entry key="904965">
                <value>
                  <list>
                    <Term value="string slices" definition="A string slice is a reference to a contiguous sequence of elements in a string collection, allowing access to a part of the string without taking ownership of it." />
                  </list>
                </value>
              </entry>
              <entry key="904970">
                <value>
                  <list>
                    <Term value="Modules" definition="Modules are used to control scope and privacy in programming by organizing code into logical units." />
                    <Term value="modules" definition="Modules are used to control scope and privacy in programming by organizing code into logical units." />
                    <Term value="module" definition="Modules are used to control scope and privacy in programming by organizing code into logical units." />
                    <Term value="paths" definition="Paths allow you to name items within a module system." />
                    <Term value="path" definition="Paths allow you to name items within a module system." />
                    <Term value="`use` keyword" definition="The `use` keyword brings a path into scope, allowing direct access to items." />
                    <Term value="`pub` keyword" definition="The `pub` keyword makes items in a module public and accessible outside the module." />
                    <Term value="`as` keyword" definition="The `as` keyword is used to create an alias for items, simplifying references or resolving naming conflicts." />
                    <Term value="external packages" definition="External packages are libraries or modules that are imported into a project to extend its functionality." />
                    <Term value="glob operator" definition="The glob operator is used to bring all items within a module or namespace into the current scope." />
                  </list>
                </value>
              </entry>
              <entry key="904971">
                <value>
                  <list>
                    <Term value="absolute path" definition="In Rust, an absolute path starts from a crate root by using a crate name or a literal `crate` and includes successive modules followed by double colons (`::`)." />
                    <Term value="Absolute path" definition="In Rust, an absolute path starts from a crate root by using a crate name or a literal `crate` and includes successive modules followed by double colons (`::`)." />
                    <Term value="absolute paths" definition="In Rust, an absolute path starts from a crate root by using a crate name or a literal `crate` and includes successive modules followed by double colons (`::`)." />
                    <Term value="relative path" definition="In Rust, a relative path starts from the current module and uses `self`, `super`, or an identifier in the current module with subsequent modules separated by double colons (`::`)." />
                    <Term value="relative paths" definition="In Rust, a relative path starts from the current module and uses `self`, `super`, or an identifier in the current module with subsequent modules separated by double colons (`::`)." />
                    <Term value="Relative path" definition="In Rust, a relative path starts from the current module and uses `self`, `super`, or an identifier in the current module with subsequent modules separated by double colons (`::`)." />
                    <Term value="privacy boundary" definition="In Rust, a privacy boundary is a line that encapsulates the implementation details external code isn’t allowed to know about, call, or rely on. All items are private by default in Rust." />
                    <Term value="`pub` keyword" definition="The `pub` keyword in Rust is used to make a function, struct, enum, module, or constant publicly accessible." />
                    <Term value="`pub` Keyword" definition="The `pub` keyword in Rust is used to make a function, struct, enum, module, or constant publicly accessible." />
                  </list>
                </value>
              </entry>
              <entry key="904972">
                <value>
                  <list>
                    <Term value="use Keyword" definition="In Rust, the `use` keyword is used to bring paths or modules into scope, allowing program elements to be referred to with shorter names within that scope." />
                    <Term value="HashMap" definition="A standard library struct in Rust used for storing data in a hash table and enabling key-value pair mappings." />
                  </list>
                </value>
              </entry>
              <entry key="904973">
                <value>
                  <list>
                    <Term value="pub use" definition="In Rust, 'pub use' makes a module or item public and brings it into scope, allowing re-exporting it for external use." />
                    <Term value="crate root file" definition="In Rust, the crate root file is the starting point for a crate's module tree, such as _src/lib.rs_ for libraries and _src/main.rs_ for binary crates." />
                  </list>
                </value>
              </entry>
              <entry key="904975">
                <value>
                  <list>
                    <Term value="module" definition="A module is a collection of items such as functions, constants, and other modules grouped together to organize code in a structured manner." />
                    <Term value="modules" definition="A module is a collection of items such as functions, constants, and other modules grouped together to organize code in a structured manner." />
                  </list>
                </value>
              </entry>
              <entry key="904980">
                <value>
                  <list>
                    <Term value="macro" definition="A macro in programming is a code pattern or rule that automatically generates code or processes input." />
                    <Term value="macros" definition="A macro in programming is a code pattern or rule that automatically generates code or processes input." />
                    <Term value="Module" definition="A module in programming is a container for grouping related functionalities, such as functions, macros, or structs." />
                    <Term value="module" definition="A module in programming is a container for grouping related functionalities, such as functions, macros, or structs." />
                    <Term value="extern crate" definition="In Rust, 'extern crate' is a command used to link to an external library or crate and make its public items available in the current module." />
                  </list>
                </value>
              </entry>
              <entry key="904983">
                <value>
                  <list>
                    <Term value="Strings" definition="The `String` type in Rust is a growable, mutable, owned, UTF-8 encoded string type provided by Rust’s standard library." />
                    <Term value="strings" definition="The `String` type in Rust is a growable, mutable, owned, UTF-8 encoded string type provided by Rust’s standard library." />
                    <Term value="String" definition="The `String` type in Rust is a growable, mutable, owned, UTF-8 encoded string type provided by Rust’s standard library." />
                    <Term value="string" definition="The `String` type in Rust is a growable, mutable, owned, UTF-8 encoded string type provided by Rust’s standard library." />
                    <Term value="&amp;str" definition="In Rust, `&amp;str` is a borrowed string slice, used to refer to some UTF-8 encoded string data stored elsewhere." />
                    <Term value="UTF-8" definition="UTF-8 is a variable-length character encoding for Unicode, which uses one to four bytes for each character and is widely used in computer programming." />
                    <Term value="OsString" definition="`OsString` is a string type in Rust’s standard library used to store system strings in an owned format." />
                    <Term value="OsStr" definition="`OsStr` is a borrowed string type in Rust used to refer to system strings stored elsewhere." />
                    <Term value="CString" definition="`CString` is a Rust string type that is used for C-style string representations, which are null-terminated and stored in an owned format." />
                    <Term value="CStr" definition="`CStr` is a borrowed Rust string type used to handle C-style strings stored elsewhere." />
                  </list>
                </value>
              </entry>
              <entry key="904984">
                <value>
                  <list>
                    <Term value="string literal" definition="A string literal is a sequence of characters used directly in source code to represent text." />
                    <Term value="String" definition="In programming, a String is a sequence of characters or text used to represent data." />
                    <Term value="string" definition="In programming, a String is a sequence of characters or text used to represent data." />
                  </list>
                </value>
              </entry>
              <entry key="904985">
                <value>
                  <list>
                    <Term value="String Slice" definition="A String slice is a reference to a part of a String, allowing efficient manipulation without copying the data." />
                    <Term value="string slice" definition="A String slice is a reference to a part of a String, allowing efficient manipulation without copying the data." />
                  </list>
                </value>
              </entry>
              <entry key="904987">
                <value>
                  <list>
                    <Term value="Result&lt;T, E&gt;" definition="In Rust, the Result&lt;T, E&gt; type is used for recoverable errors and represents either a success (T) or an error (E)." />
                    <Term value="recoverable error" definition="In Rust, recoverable errors are issues like a file not found error where it's reasonable to report the problem and retry the operation." />
                    <Term value="recoverable errors" definition="In Rust, recoverable errors are issues like a file not found error where it's reasonable to report the problem and retry the operation." />
                    <Term value="Unrecoverable errors" definition="In Rust, unrecoverable errors are symptoms of bugs, such as trying to access a location beyond the end of an array." />
                    <Term value="unrecoverable error" definition="In Rust, unrecoverable errors are symptoms of bugs, such as trying to access a location beyond the end of an array." />
                  </list>
                </value>
              </entry>
              <entry key="904988">
                <value>
                  <list>
                    <Term value="File::open" definition="In Rust, File::open is a function used to open a file. It returns a Result enum which can be Ok if the file opens successfully or Err if there is an error such as the file not existing or lacking the correct permissions." />
                  </list>
                </value>
              </entry>
              <entry key="904990">
                <value>
                  <list>
                    <Term value="Result" definition="In Rust, the Result type is used for functions that can return an error. It encapsulates the idea of success (Ok) and failure (Err) within a single return type." />
                    <Term value="Option" definition="In Rust, the Option type is used to represent a value that might or might not exist. It encapsulates the idea of Some(value) or None." />
                    <Term value="Ok" definition="In Rust, Ok is a variant of the Result type that represents a successful operation, containing the desired result." />
                    <Term value="Err" definition="In Rust, Err is a variant of the Result type that represents an unsuccessful operation, containing an error message or value." />
                  </list>
                </value>
              </entry>
              <entry key="904991">
                <value>
                  <list>
                    <Term value="ParseIntError" definition="In Rust, ParseIntError is an error that occurs when a string cannot be parsed into an integer due to invalid input." />
                    <Term value="match statement" definition="In Rust, a match statement is a control flow construct used to destructure and match patterns in data, executing code for matching cases." />
                  </list>
                </value>
              </entry>
              <entry key="904993">
                <value>
                  <list>
                    <Term value="Result" definition="Result is an enum in Rust used for error handling, typically representing either success (Ok) or failure (Err) of a function." />
                    <Term value="? Operator" definition="The ? operator in Rust is used to propagate errors, automatically converting them using traits like From::from." />
                    <Term value="From::from" definition="From::from is a trait in Rust used to convert one type into another, often utilized for error conversions." />
                    <Term value="error::Error" definition="error::Error is a trait in Rust that all error types implement, enabling consistent handling of different error kinds." />
                  </list>
                </value>
              </entry>
              <entry key="904999">
                <value>
                  <list>
                    <Term value="Correctness" definition="Correctness in programming is the extent to which code does what it is intended to do." />
                    <Term value="correctness" definition="Correctness in programming is the extent to which code does what it is intended to do." />
                    <Term value="automated software tests" definition="In Rust, automated software tests are written within the language to check if code behaves as intended." />
                    <Term value="unit tests" definition="Unit tests in Rust are a way to organize tests to validate individual components' functionality." />
                    <Term value="integration tests" definition="Integration tests in Rust are used to check how multiple components of a program work together." />
                  </list>
                </value>
              </entry>
              <entry key="905000">
                <value>
                  <list>
                    <Term value="RUST_BACKTRACE" definition="In Rust, the RUST_BACKTRACE environment variable enables backtrace information during a program crash for debugging purposes." />
                  </list>
                </value>
              </entry>
              <entry key="905001">
                <value>
                  <list>
                    <Term value="assert!" definition="assert! is a macro that needs an argument. Depending on the value of the argument, assert! will either do nothing (test passes) or panic (test fails)." />
                  </list>
                </value>
              </entry>
              <entry key="905002">
                <value>
                  <list>
                    <Term value="assert_eq!" definition="assert_eq! is a macro in Rust programming language that takes two arguments and compares them." />
                  </list>
                </value>
              </entry>
              <entry key="905005">
                <value>
                  <list>
                    <Term value="iterator" definition="An iterator is responsible for the logic of iterating over each item in a sequence and determining when the sequence has finished." />
                  </list>
                </value>
              </entry>
              <entry key="905006">
                <value>
                  <list>
                    <Term value="Shared memory concurrency" definition="Shared memory concurrency allows multiple threads to access the same memory location at the same time, requiring management for these different owners." />
                  </list>
                </value>
              </entry>
              <entry key="905007">
                <value>
                  <list>
                    <Term value="Arc" definition="Arc stands for 'Atomic Reference Counting'. In Rust, it is a thread-safe reference-counting pointer used to share ownership of a value across multiple threads and ensure mutual access to the data." />
                    <Term value="Vec" definition="Vec is Rust's dynamic, heap-allocated array type that allows storing and manipulating a collection of elements of the same type." />
                    <Term value="clone" definition="Clone is a trait in Rust that provides the functionality to create a duplicate of an object, particularly useful for types that need deep copying of data." />
                  </list>
                </value>
              </entry>
              <entry key="905012">
                <value>
                  <list>
                    <Term value="Message Passing" definition="An approach to ensure safe concurrency where threads or actors communicate by sending each other messages containing data." />
                    <Term value="message passing" definition="An approach to ensure safe concurrency where threads or actors communicate by sending each other messages containing data." />
                    <Term value="channel" definition="A programming concept with two halves: a transmitter and a receiver, used for sending and receiving data in concurrency. A channel is closed if either the transmitter or receiver is dropped." />
                    <Term value="channels" definition="A programming concept with two halves: a transmitter and a receiver, used for sending and receiving data in concurrency. A channel is closed if either the transmitter or receiver is dropped." />
                  </list>
                </value>
              </entry>
              <entry key="905014">
                <value>
                  <list>
                    <Term value="Arc" definition="Arc is an Atomic Reference Counted pointer that allows safe shared access to immutable data." />
                    <Term value="Mutex" definition="Mutex is used to ensure that only one thread has access to certain data at a time, enabling safe mutation across multiple threads." />
                    <Term value="mutex" definition="Mutex is used to ensure that only one thread has access to certain data at a time, enabling safe mutation across multiple threads." />
                  </list>
                </value>
              </entry>
              <entry key="14132382">
                <value>
                  <list>
                    <Term value="Enums" definition="Enums, or enumerations, allow you to define a type by enumerating its possible variants." />
                    <Term value="enums" definition="Enums, or enumerations, allow you to define a type by enumerating its possible variants." />
                    <Term value="Option" definition="Option is a particularly useful enum that expresses that a value can be either something or nothing." />
                    <Term value="pattern matching" definition="Pattern matching in the `match` expression makes it easy to run different code for different values of an enum." />
                    <Term value="algebraic data types" definition="Rust’s enums are most similar to algebraic data types in functional languages, such as F#, OCaml, and Haskell." />
                  </list>
                </value>
              </entry>
              <entry key="28112392">
                <value>
                  <list>
                    <Term value="Shadowing" definition="In Rust, Shadowing allows you to reuse an existing variable name with a new value or different type in the same scope." />
                  </list>
                </value>
              </entry>
              <entry key="40951438">
                <value>
                  <list>
                    <Term value="generic types" definition="In programming, a generic type is a placeholder type used in code where the specific type is determined when the code runs, allowing for type safety and flexibility." />
                    <Term value="generic type" definition="In programming, a generic type is a placeholder type used in code where the specific type is determined when the code runs, allowing for type safety and flexibility." />
                    <Term value="structs" definition="In Rust, a struct is a user-defined data type that groups together related data under one name, with fields that can be of different data types." />
                    <Term value="Structs" definition="In Rust, a struct is a user-defined data type that groups together related data under one name, with fields that can be of different data types." />
                    <Term value="struct" definition="In Rust, a struct is a user-defined data type that groups together related data under one name, with fields that can be of different data types." />
                    <Term value="Method" definition="In Rust, a method is a function defined in the context of an impl block and is associated with a struct, enum, or trait object." />
                    <Term value="methods" definition="In Rust, a method is a function defined in the context of an impl block and is associated with a struct, enum, or trait object." />
                    <Term value="method" definition="In Rust, a method is a function defined in the context of an impl block and is associated with a struct, enum, or trait object." />
                    <Term value="concrete type" definition="In Rust, a concrete type refers to a specific type used in place of a generic type, such as using f32 instead of T." />
                    <Term value="distance_from_origin" definition="In this Rust code, distance_from_origin is a method defined for the Point struct with the concrete type f32, which calculates the distance of the point from the origin using the Pythagorean theorem." />
                  </list>
                </value>
              </entry>
              <entry key="51522697">
                <value>
                  <list>
                    <Term value="string literals" definition="In Rust, string literals have the 'static lifetime, meaning their text is stored directly in the program’s binary and is always available." />
                    <Term value="dangling reference" definition="A dangling reference in Rust occurs when a program tries to use a reference that is no longer valid." />
                  </list>
                </value>
              </entry>
              <entry key="56206075">
                <value>
                  <list>
                    <Term value="trait bound" definition="A longer form of specifying that a type parameter in a generic function implements a specific trait, using a colon and angle brackets." />
                  </list>
                </value>
              </entry>
              <entry key="60722631">
                <value>
                  <list>
                    <Term value="Slice" definition="In Rust, a slice is a view into a sequence of elements in a collection, such as an array, without taking ownership of the collection." />
                    <Term value="slice" definition="In Rust, a slice is a view into a sequence of elements in a collection, such as an array, without taking ownership of the collection." />
                    <Term value="Slices" definition="In Rust, a slice is a view into a sequence of elements in a collection, such as an array, without taking ownership of the collection." />
                    <Term value="Deref coercions" definition="In Rust, deref coercion is a convenience that automatically converts a reference to a type that implements the Deref trait into that type's target type." />
                  </list>
                </value>
              </entry>
              <entry key="62649169">
                <value>
                  <list>
                    <Term value="iterator" definition="An iterator is a construct that allows for traversing elements within a collection, performing operations on each item sequentially." />
                    <Term value="Iterator" definition="An iterator is a construct that allows for traversing elements within a collection, performing operations on each item sequentially." />
                    <Term value="Iterable Collection" definition="An iterable collection is a data structure that can be traversed element by element using an iterator." />
                    <Term value="iterable collection" definition="An iterable collection is a data structure that can be traversed element by element using an iterator." />
                  </list>
                </value>
              </entry>
              <entry key="64149064">
                <value>
                  <list>
                    <Term value="Introduce Variable Refactoring" definition="A functionality in certain IDEs, such as %IDE_NAME%, that allows developers to select a value in the code and quickly replace it with a variable." />
                    <Term value="Refactoring" definition="The process of restructuring existing code without changing its external behavior to improve its structure and readability." />
                    <Term value="refactor" definition="The process of restructuring existing code without changing its external behavior to improve its structure and readability." />
                    <Term value="Refactor" definition="The process of restructuring existing code without changing its external behavior to improve its structure and readability." />
                    <Term value="Introduce Constant" definition="An action in IDEs that allows developers to replace a hardcoded value with a constant to use uniformly across the code." />
                  </list>
                </value>
              </entry>
              <entry key="71460633">
                <value>
                  <list>
                    <Term value="enum" definition="In Rust, an enum is a custom type that can have one of a set of enumerated values." />
                    <Term value="Option&lt;T&gt;" definition="Option&lt;T&gt; in Rust is a standard library type that helps prevent errors by using the type system to represent a value that might be either something or nothing." />
                    <Term value="match" definition="In Rust, match is a control flow construct used to compare a value against a series of patterns and execute code based on which pattern matches." />
                    <Term value="if let" definition="In Rust, if let is a construct used for concisely handling cases where you want to execute code only if a pattern matches a value." />
                  </list>
                </value>
              </entry>
              <entry key="71775849">
                <value>
                  <list>
                    <Term value="Traits" definition="In Rust, a Trait tells the compiler about functionality a particular type has and can share with other types. Traits are used to define shared behavior in an abstract way." />
                    <Term value="trait" definition="In Rust, a Trait tells the compiler about functionality a particular type has and can share with other types. Traits are used to define shared behavior in an abstract way." />
                    <Term value="traits" definition="In Rust, a Trait tells the compiler about functionality a particular type has and can share with other types. Traits are used to define shared behavior in an abstract way." />
                    <Term value="interfaces" definition="In programming, an Interface is a feature in many languages that is similar to Rust traits, although with some differences." />
                  </list>
                </value>
              </entry>
              <entry key="73167570">
                <value>
                  <list>
                    <Term value="cargo test" definition="A Rust command that compiles code in test mode and runs the resulting test binary, allowing for testing and debugging in Rust projects." />
                    <Term value="--test-threads" definition="A flag in Rust that allows for setting the number of threads used for running tests, providing control over parallel test execution." />
                    <Term value="--show-output" definition="A flag used with `cargo test` to display the output of passing tests, which is otherwise captured and not displayed." />
                    <Term value="assert_eq!" definition="A macro in Rust used to assert that two expressions are equal during tests." />
                  </list>
                </value>
              </entry>
              <entry key="80910339">
                <value>
                  <list>
                    <Term value="ParseClimateError" definition="A custom error type that can be propagated in the `main()` function for handling parsing errors related to climate data." />
                    <Term value="Errors" definition="A trait in Rust (`std::error::Error`) that represents basic expectations for error values." />
                    <Term value="error" definition="A trait in Rust (`std::error::Error`) that represents basic expectations for error values." />
                    <Term value="Error" definition="A trait in Rust (`std::error::Error`) that represents basic expectations for error values." />
                    <Term value="From" definition="A trait in Rust that provides a way to convert between types, often used for automatic error conversion." />
                    <Term value="FromStr" definition="A trait in Rust used for parsing a string into a value, which can handle errors via custom implementations." />
                    <Term value="Display" definition="A trait in Rust used to convert a type into a user-facing string representation, often implemented for custom error types to provide readable error messages." />
                    <Term value="Climate" definition="A custom type that includes the fields `city`, `year`, and `temp`, parsed from a string input." />
                    <Term value="Box&lt;dyn Error&gt;" definition="A type in Rust used to encapsulate any error type, allowing for dynamic dispatch of error types at runtime." />
                  </list>
                </value>
              </entry>
              <entry key="80983513">
                <value>
                  <list>
                    <Term value="Borrow Checker" definition="In Rust, the Borrow Checker is a component of the compiler that compares scopes to determine whether all borrows are valid." />
                    <Term value="dangling reference" definition="A Dangling Reference in Rust happens when a reference points to memory that is no longer valid due to the owner's scope ending." />
                  </list>
                </value>
              </entry>
              <entry key="84267066">
                <value>
                  <list>
                    <Term value="thread::spawn" definition="In Rust, the thread::spawn function is used to create a new thread, allowing code within a closure to execute concurrently." />
                    <Term value="closure" definition="In Rust, a closure is an anonymous function that can capture variables from its surrounding scope." />
                    <Term value="closures" definition="In Rust, a closure is an anonymous function that can capture variables from its surrounding scope." />
                    <Term value="thread::sleep" definition="In Rust, the thread::sleep function pauses the current thread's execution for a specified duration of time." />
                  </list>
                </value>
              </entry>
              <entry key="102681658">
                <value>
                  <list>
                    <Term value="while loop" definition="In Rust, a while loop runs code repeatedly as long as a specified condition holds true, eliminating the need for additional nesting with constructs like loop, if, else, and break." />
                  </list>
                </value>
              </entry>
              <entry key="117319845">
                <value>
                  <list>
                    <Term value="Default Implementations" definition="In Rust, a default implementation provides predefined behavior for methods in traits, allowing implementing types to use or override them." />
                    <Term value="default implementation" definition="In Rust, a default implementation provides predefined behavior for methods in traits, allowing implementing types to use or override them." />
                  </list>
                </value>
              </entry>
              <entry key="118579404">
                <value>
                  <list>
                    <Term value="match arms" definition="A feature in Rust's match expressions that binds values matching a pattern, enabling further use of the values in the associated code block." />
                    <Term value="enum" definition="A type in Rust that can have multiple variants, optionally holding data, such as the Coin enum with Penny, Nickel, Dime, and Quarter variants." />
                  </list>
                </value>
              </entry>
              <entry key="129748376">
                <value>
                  <list>
                    <Term value="Data Types" definition="In Rust, a data type tells the compiler what kind of data is being specified so it knows how to work with that data." />
                    <Term value="data type" definition="In Rust, a data type tells the compiler what kind of data is being specified so it knows how to work with that data." />
                    <Term value="data types" definition="In Rust, a data type tells the compiler what kind of data is being specified so it knows how to work with that data." />
                    <Term value="statically typed language" definition="A language in which the types of all variables must be known at compile time." />
                    <Term value="type annotation" definition="A specification added in Rust to tell the compiler the exact type of a variable when it cannot infer it on its own." />
                    <Term value="type annotations" definition="A specification added in Rust to tell the compiler the exact type of a variable when it cannot infer it on its own." />
                    <Term value="scalar types" definition="In Rust, a scalar type represents a single value, such as integers, floating-point numbers, Booleans, and characters." />
                    <Term value="Scalar Types" definition="In Rust, a scalar type represents a single value, such as integers, floating-point numbers, Booleans, and characters." />
                  </list>
                </value>
              </entry>
              <entry key="140075486">
                <value>
                  <list>
                    <Term value="Catch-all Patterns" definition="In Rust, a catch-all pattern in a match expression is used to match all possible values not covered by earlier patterns." />
                    <Term value="catch-all pattern" definition="In Rust, a catch-all pattern in a match expression is used to match all possible values not covered by earlier patterns." />
                    <Term value="exhaustiveness requirement" definition="In Rust, the exhaustiveness requirement ensures that a match expression accounts for every possible value that a variable could have." />
                  </list>
                </value>
              </entry>
              <entry key="150081369">
                <value>
                  <list>
                    <Term value="Struct Update Syntax" definition="In Rust, struct update syntax is a shorthand that allows creating a new instance of a struct by specifying changed values while copying the remaining values from an existing instance using `..` syntax." />
                    <Term value="struct update syntax" definition="In Rust, struct update syntax is a shorthand that allows creating a new instance of a struct by specifying changed values while copying the remaining values from an existing instance using `..` syntax." />
                  </list>
                </value>
              </entry>
              <entry key="153461655">
                <value>
                  <list>
                    <Term value="Generic type parameters" definition="Generic type parameters allow you to apply code to different types, reducing code repetition and making it applicable to various situations." />
                    <Term value="traits and trait bounds" definition="Traits and trait bounds ensure that even though the types are generic, they exhibit the behavior required by the code." />
                    <Term value="lifetime annotations" definition="Lifetime annotations ensure that flexible code doesn’t have dangling references, enforcing memory safety during compile time." />
                  </list>
                </value>
              </entry>
              <entry key="167581962">
                <value>
                  <list>
                    <Term value="immutable borrow" definition="In Rust, an immutable borrow refers to borrowing a reference to a value without allowing modifications to the value." />
                    <Term value="Boolean" definition="A Boolean is a data type in Rust that represents true or false values." />
                    <Term value="Methods" definition="In Rust, a method is a function defined within the `impl` block and is associated with an instance of a type." />
                    <Term value="methods" definition="In Rust, a method is a function defined within the `impl` block and is associated with an instance of a type." />
                    <Term value="method" definition="In Rust, a method is a function defined within the `impl` block and is associated with an instance of a type." />
                  </list>
                </value>
              </entry>
              <entry key="167626233">
                <value>
                  <list>
                    <Term value="Lifetime Annotations" definition="In Rust, lifetime annotations specify the scope for which a reference is valid. They are represented with generic parameters like `'a` and ensure that references do not outlive their valid scope." />
                    <Term value="lifetime annotations" definition="In Rust, lifetime annotations specify the scope for which a reference is valid. They are represented with generic parameters like `'a` and ensure that references do not outlive their valid scope." />
                    <Term value="string slices" definition="A string slice in Rust, denoted as `&amp;str`, is a reference to a sequence of UTF-8 characters that do not have ownership." />
                  </list>
                </value>
              </entry>
              <entry key="171279379">
                <value>
                  <list>
                    <Term value="Iterator" definition="An Iterator in Rust is a trait that allows sequential access to elements within a collection. Methods from the Iterator trait are used for tasks like transforming or filtering data." />
                    <Term value="iterator" definition="An Iterator in Rust is a trait that allows sequential access to elements within a collection. Methods from the Iterator trait are used for tasks like transforming or filtering data." />
                    <Term value="for loops" definition="In Rust, a for loop is an imperative construct used for iterating over elements in a range or collection." />
                  </list>
                </value>
              </entry>
              <entry key="172074781">
                <value>
                  <list>
                    <Term value="Re-exporting" definition="Re-exporting in Rust is a technique where an item is brought into scope using the `use` keyword combined with `pub`, making it available for external code to use as if it were defined directly in that scope." />
                    <Term value="re-exporting" definition="Re-exporting in Rust is a technique where an item is brought into scope using the `use` keyword combined with `pub`, making it available for external code to use as if it were defined directly in that scope." />
                    <Term value="pub use" definition="In Rust, `pub use` is used to make an item available not only for the current scope but also for any external code to import and use." />
                  </list>
                </value>
              </entry>
              <entry key="178354253">
                <value>
                  <list>
                    <Term value="Clippy" definition="Clippy is an external linter tool for Rust programming, used to provide suggestions and improve code quality." />
                    <Term value="Option" definition="In Rust, Option is an enum that represents a value that can either be Some(T) for a value of type T or None for no value." />
                    <Term value="option" definition="In Rust, Option is an enum that represents a value that can either be Some(T) for a value of type T or None for no value." />
                    <Term value="if let" definition="if let is a Rust construct used for concise handling of pattern matching, often used with Option and Result." />
                  </list>
                </value>
              </entry>
              <entry key="196849707">
                <value>
                  <list>
                    <Term value="Arc&lt;T&gt;" definition="In Rust, Arc&lt;T&gt; is an atomically reference counted type that is safe to use in concurrent situations, allowing shared ownership across threads." />
                    <Term value="Mutex&lt;T&gt;" definition="In Rust, Mutex&lt;T&gt; is used to ensure mutual exclusion, enabling safe access to data shared between threads by locking and unlocking a resource." />
                    <Term value="std::sync::atomic" definition="In Rust, std::sync::atomic provides atomic operations and types that are safe to share across threads, functioning like primitive types with thread safety guarantees." />
                  </list>
                </value>
              </entry>
              <entry key="201498006">
                <value>
                  <list>
                    <Term value="Option&lt;T&gt;" definition="A Rust enum used to encode the presence (Some) or absence (None) of a value of type T." />
                  </list>
                </value>
              </entry>
              <entry key="208184793">
                <value>
                  <list>
                    <Term value="FromStr" definition="In Rust, the FromStr trait is used to define how a type can be created from a string slice, returning a Result type that indicates success or failure." />
                    <Term value="map_err" definition="In Rust, the map_err method on Result allows transforming the error value of the Result with a function or closure." />
                    <Term value="parse::&lt;usize&gt;()" definition="In Rust, the parse::&lt;usize&gt;() method attempts to parse a string slice into a usize type, which is a potentially architecture-dependent unsigned integer." />
                  </list>
                </value>
              </entry>
              <entry key="213737535">
                <value>
                  <list>
                    <Term value="if expression" definition="In Rust, `if` is an expression that evaluates to a value, and its result can be assigned to a variable." />
                  </list>
                </value>
              </entry>
              <entry key="219173847">
                <value>
                  <list>
                    <Term value="Generic Data Types" definition="Generic Data Types allow creating definitions for items like function signatures or structs, which can be used with various concrete data types." />
                  </list>
                </value>
              </entry>
              <entry key="225553404">
                <value>
                  <list>
                    <Term value="Generic type parameters" definition="Generic type parameters allow structs and methods to operate on different types without being specific to one." />
                    <Term value="Point&lt;T, U&gt;" definition="A struct definition in Rust where 'x' is of type 'T' and 'y' is of type 'U', allowing flexible usage with various types." />
                  </list>
                </value>
              </entry>
              <entry key="250421919">
                <value>
                  <list>
                    <Term value="mpsc" definition="An acronym for multiple producer, single consumer in Rust, referring to a communication channel for transferring data between threads where multiple threads can send messages to a single receiver." />
                    <Term value="thread::spawn" definition="A function in Rust used to create a new thread for concurrent execution of code." />
                    <Term value="thread::sleep" definition="A function in Rust that pauses the current thread's execution for a specified duration of time." />
                    <Term value="tx.clone()" definition="A method in Rust used to clone the sending end of a channel, allowing multiple threads to send messages to the same receiver." />
                    <Term value="tx.send(val).unwrap()" definition="A method used in Rust to send a value through the sending end of a channel, with `.unwrap()` ensuring the program panics if the send operation fails." />
                  </list>
                </value>
              </entry>
              <entry key="257982860">
                <value>
                  <list>
                    <Term value="Procedural Macros" definition="Procedural macros in Rust act more like functions and accept some code as an input, operate on that code, and produce some code as output." />
                    <Term value="procedural macros" definition="Procedural macros in Rust act more like functions and accept some code as an input, operate on that code, and produce some code as output." />
                    <Term value="Procedural macros" definition="Procedural macros in Rust act more like functions and accept some code as an input, operate on that code, and produce some code as output." />
                    <Term value="procedural macro" definition="Procedural macros in Rust act more like functions and accept some code as an input, operate on that code, and produce some code as output." />
                    <Term value="TokenStream" definition="In Rust, TokenStream is a type defined by the proc_macro crate representing a sequence of tokens, used as both the input and output for procedural macros." />
                  </list>
                </value>
              </entry>
              <entry key="264790944">
                <value>
                  <list>
                    <Term value="if let" definition="`if let` is a syntax in Rust that combines `if` and `let`, allowing concise handling of specific pattern matches while ignoring the rest." />
                    <Term value="match" definition="In Rust, `match` is a control flow structure that compares a value against multiple patterns and executes code based on which pattern matches." />
                    <Term value="matches" definition="In Rust, `match` is a control flow structure that compares a value against multiple patterns and executes code based on which pattern matches." />
                    <Term value="syntax sugar" definition="Syntax sugar in programming refers to language features that make code easier to read and write, often by simplifying more verbose patterns." />
                  </list>
                </value>
              </entry>
              <entry key="265159969">
                <value>
                  <list>
                    <Term value="tuple" definition="In Rust, a Tuple is a collection of values of different types grouped together into a single compound type, allowing you to return multiple values from a function." />
                    <Term value="tuple index" definition="Tuple indexing in Rust allows accessing elements of a tuple using a zero-based index, for example, dimensions.0 for the first element." />
                  </list>
                </value>
              </entry>
              <entry key="270124130">
                <value>
                  <list>
                    <Term value="Lifetime" definition="In Rust, a Lifetime is a construct the compiler uses to ensure that references are valid as long as they're needed and no longer to prevent potential invalid data access." />
                    <Term value="lifetime" definition="In Rust, a Lifetime is a construct the compiler uses to ensure that references are valid as long as they're needed and no longer to prevent potential invalid data access." />
                    <Term value="lifetimes" definition="In Rust, a Lifetime is a construct the compiler uses to ensure that references are valid as long as they're needed and no longer to prevent potential invalid data access." />
                    <Term value="borrow checker" definition="In Rust, the Borrow checker is a component that ensures references and pointers in a program satisfy Rust's ownership rules at compile time." />
                    <Term value="Scope" definition="In programming, Scope refers to the context within a program in which a variable or reference is defined and beyond which it is not accessible." />
                    <Term value="scope" definition="In programming, Scope refers to the context within a program in which a variable or reference is defined and beyond which it is not accessible." />
                  </list>
                </value>
              </entry>
              <entry key="274275577">
                <value>
                  <list>
                    <Term value="Enum" definition="In Rust, enum is a feature that allows defining a type by enumerating its possible variants." />
                    <Term value="enum" definition="In Rust, enum is a feature that allows defining a type by enumerating its possible variants." />
                    <Term value="structs" definition="In Rust, a struct is used to create a custom data type that groups related data together." />
                    <Term value="struct" definition="In Rust, a struct is used to create a custom data type that groups related data together." />
                    <Term value="IpAddrKind" definition="In Rust, IpAddrKind is a user-defined enum with variants V4 and V6 that represent different kinds of IP addresses." />
                  </list>
                </value>
              </entry>
              <entry key="291828379">
                <value>
                  <list>
                    <Term value="dereference operator (`*`)" definition="Used to access or modify the value that a reference points to in Rust." />
                    <Term value="for loop" definition="A control structure for iterating over elements in a collection, such as a vector." />
                    <Term value="immutable references" definition="A reference that allows read-only access to a value in Rust." />
                    <Term value="mutable references" definition="A reference that allows modification of the value it points to in Rust." />
                    <Term value="mutable reference" definition="A reference that allows modification of the value it points to in Rust." />
                  </list>
                </value>
              </entry>
              <entry key="296701909">
                <value>
                  <list>
                    <Term value="unwrap_or_else" definition="A method in Rust for the Option&lt;T&gt; type that returns the value inside the Option if it is Some, or computes and returns a value via a closure if it is None." />
                    <Term value="Option&lt;T&gt;" definition="A Rust enum that represents either a value of type T (Some) or no value (None)." />
                    <Term value="FnOnce" definition="A trait in Rust that allows a function or closure to be called exactly one time." />
                  </list>
                </value>
              </entry>
              <entry key="297625680">
                <value>
                  <list>
                    <Term value="Lifetime Elision" definition="A feature in Rust where the compiler applies predefined rules to determine lifetimes of references when they are not explicitly annotated." />
                    <Term value="lifetime elision" definition="A feature in Rust where the compiler applies predefined rules to determine lifetimes of references when they are not explicitly annotated." />
                    <Term value="input lifetimes" definition="Lifetimes on function or method parameters in Rust." />
                    <Term value="input lifetime" definition="Lifetimes on function or method parameters in Rust." />
                    <Term value="output lifetimes" definition="Lifetimes on return values from functions or methods in Rust." />
                    <Term value="output lifetime" definition="Lifetimes on return values from functions or methods in Rust." />
                  </list>
                </value>
              </entry>
              <entry key="303501042">
                <value>
                  <list>
                    <Term value="Lifetimes" definition="In Rust, a Lifetime is the scope for which a reference is valid, ensuring references used at runtime are definitely valid." />
                    <Term value="lifetime" definition="In Rust, a Lifetime is the scope for which a reference is valid, ensuring references used at runtime are definitely valid." />
                    <Term value="lifetimes" definition="In Rust, a Lifetime is the scope for which a reference is valid, ensuring references used at runtime are definitely valid." />
                  </list>
                </value>
              </entry>
              <entry key="311737426">
                <value>
                  <list>
                    <Term value="Unicode scalar values" definition="A Unicode scalar value is any Unicode code point except high-surrogate and low-surrogate code points." />
                  </list>
                </value>
              </entry>
              <entry key="318636675">
                <value>
                  <list>
                    <Term value="Option::flatten" definition="In Rust, Option::flatten is used to convert nested Option values (Option&lt;Option&lt;T&gt;&gt;) into a single-layer Option value (Option&lt;T&gt;)." />
                    <Term value="if let" definition="In Rust, if let is a construct used for pattern matching in conditional statements, allowing for concise handling of specific patterns." />
                    <Term value="while let" definition="In Rust, while let is a construct used for pattern matching in loops, enabling iterative handling of specific patterns." />
                  </list>
                </value>
              </entry>
              <entry key="319957584">
                <value>
                  <list>
                    <Term value="iterator adaptors" definition="An Iterator method in Rust that transforms one iterator into another, allowing chaining for complex operations." />
                    <Term value="iterator adaptor" definition="An Iterator method in Rust that transforms one iterator into another, allowing chaining for complex operations." />
                    <Term value="map method" definition="An iterator adaptor in Rust that takes a closure to apply to each item, producing a new iterator." />
                    <Term value="collect method" definition="A method in Rust that consumes an iterator and collects the resulting values into a collection data type like a vector." />
                  </list>
                </value>
              </entry>
              <entry key="328918674">
                <value>
                  <list>
                    <Term value="generic lifetime parameter" definition="A mechanism in Rust that defines the relationship between lifetimes of references in function signatures to ensure valid borrowing." />
                    <Term value="generic lifetime parameters" definition="A mechanism in Rust that defines the relationship between lifetimes of references in function signatures to ensure valid borrowing." />
                    <Term value="string slices" definition="String slices in Rust are references to a portion of a string, allowing functions to work with parts of a string without taking ownership of it." />
                    <Term value="string slice" definition="String slices in Rust are references to a portion of a string, allowing functions to work with parts of a string without taking ownership of it." />
                    <Term value="String Slices" definition="String slices in Rust are references to a portion of a string, allowing functions to work with parts of a string without taking ownership of it." />
                    <Term value="borrow checker" definition="A Rust component that enforces ownership rules to ensure references to memory are valid and prevent data races." />
                  </list>
                </value>
              </entry>
              <entry key="333362320">
                <value>
                  <list>
                    <Term value="assert_eq! macro" definition="A Rust macro that compares two arguments for equality and prints the two values if the assertion fails." />
                    <Term value="assert_ne! Macros" definition="A Rust macro that tests if two arguments are not equal and prints the two values if the assertion fails." />
                  </list>
                </value>
              </entry>
              <entry key="337862672">
                <value>
                  <list>
                    <Term value="Trait" definition="A Trait is a common feature in Rust used to define shared behavior among types." />
                    <Term value="traits" definition="A Trait is a common feature in Rust used to define shared behavior among types." />
                    <Term value="trait" definition="A Trait is a common feature in Rust used to define shared behavior among types." />
                    <Term value="AppendBar" definition="AppendBar is a trait with a function that appends 'Bar' to any object implementing this trait in Rust." />
                  </list>
                </value>
              </entry>
              <entry key="346426210">
                <value>
                  <list>
                    <Term value="HashMap" definition="A collection in Rust that stores key-value pairs. Keys must be unique and of the same type, and values must also be of the same type." />
                    <Term value="HashMap::new" definition="A function in Rust's collections library used to create a new, empty HashMap." />
                  </list>
                </value>
              </entry>
              <entry key="347744254">
                <value>
                  <list>
                    <Term value="impl Trait" definition="In Rust, `impl Trait` syntax can be used in the return position of a function to specify that the function returns some type that implements a particular trait without naming the concrete type." />
                    <Term value="closures" definition="In Rust, a closure is a lightweight, anonymous function that can capture variables from its enclosing scope." />
                    <Term value="Closures" definition="In Rust, a closure is a lightweight, anonymous function that can capture variables from its enclosing scope." />
                  </list>
                </value>
              </entry>
              <entry key="353808836">
                <value>
                  <list>
                    <Term value="super" definition="In Rust, `super` is used at the start of a relative path to reference an item in the parent module of the current module." />
                    <Term value="Relative Paths" definition="In Rust, relative paths are paths that start from the current module, parent module using `super`, or the crate root, and are used to reference items." />
                    <Term value="relative paths" definition="In Rust, relative paths are paths that start from the current module, parent module using `super`, or the crate root, and are used to reference items." />
                    <Term value="relative path" definition="In Rust, relative paths are paths that start from the current module, parent module using `super`, or the crate root, and are used to reference items." />
                  </list>
                </value>
              </entry>
              <entry key="393564051">
                <value>
                  <list>
                    <Term value="string slice" definition="A string slice in Rust is a reference to a portion of a string, defined by a range of byte indices." />
                    <Term value="string slices" definition="A string slice in Rust is a reference to a portion of a string, defined by a range of byte indices." />
                    <Term value="panic at runtime" definition="In Rust, a panic at runtime occurs when the program encounters an invalid operation, such as accessing a byte index that doesn't align with a character boundary in a string." />
                  </list>
                </value>
              </entry>
              <entry key="400448326">
                <value>
                  <list>
                    <Term value="Structs" definition="A custom data type in Rust that allows grouping together related fields with defined types." />
                    <Term value="structs" definition="A custom data type in Rust that allows grouping together related fields with defined types." />
                    <Term value="struct" definition="A custom data type in Rust that allows grouping together related fields with defined types." />
                    <Term value="Rectangle" definition="A struct in Rust containing two fields: width and height, both of type u32, used to represent a rectangle." />
                    <Term value="rectangle" definition="A struct in Rust containing two fields: width and height, both of type u32, used to represent a rectangle." />
                  </list>
                </value>
              </entry>
              <entry key="431804675">
                <value>
                  <list>
                    <Term value="data races" definition="A data race occurs when two or more pointers access the same data at the same time, at least one pointer is used to write, and there’s no mechanism to synchronize access." />
                    <Term value="data race" definition="A data race occurs when two or more pointers access the same data at the same time, at least one pointer is used to write, and there’s no mechanism to synchronize access." />
                    <Term value="Data races" definition="A data race occurs when two or more pointers access the same data at the same time, at least one pointer is used to write, and there’s no mechanism to synchronize access." />
                  </list>
                </value>
              </entry>
              <entry key="467192666">
                <value>
                  <list>
                    <Term value="Tuple Structs" definition="Tuple structs in Rust are structs that look like tuples but include a name for added meaning. They don't have named fields, only types, and are distinct types even if the fields have the same types." />
                    <Term value="Tuple structs" definition="Tuple structs in Rust are structs that look like tuples but include a name for added meaning. They don't have named fields, only types, and are distinct types even if the fields have the same types." />
                    <Term value="tuple struct" definition="Tuple structs in Rust are structs that look like tuples but include a name for added meaning. They don't have named fields, only types, and are distinct types even if the fields have the same types." />
                    <Term value="tuple structs" definition="Tuple structs in Rust are structs that look like tuples but include a name for added meaning. They don't have named fields, only types, and are distinct types even if the fields have the same types." />
                    <Term value="Unit-Like Structs" definition="Unit-like structs in Rust are structs without any fields, behaving similarly to the unit type `()`. They are useful for implementing traits on a type without storing data in it." />
                    <Term value="unit-like structs" definition="Unit-like structs in Rust are structs without any fields, behaving similarly to the unit type `()`. They are useful for implementing traits on a type without storing data in it." />
                    <Term value="Unit-like structs" definition="Unit-like structs in Rust are structs without any fields, behaving similarly to the unit type `()`. They are useful for implementing traits on a type without storing data in it." />
                  </list>
                </value>
              </entry>
              <entry key="493564259">
                <value>
                  <list>
                    <Term value="Closure" definition="A closure is similar to a function but doesn’t require explicit type annotations for its parameters or return value as the compiler infers them based on the context." />
                    <Term value="closures" definition="A closure is similar to a function but doesn’t require explicit type annotations for its parameters or return value as the compiler infers them based on the context." />
                    <Term value="Closures" definition="A closure is similar to a function but doesn’t require explicit type annotations for its parameters or return value as the compiler infers them based on the context." />
                    <Term value="closure" definition="A closure is similar to a function but doesn’t require explicit type annotations for its parameters or return value as the compiler infers them based on the context." />
                    <Term value="Type annotations" definition="Type annotations explicitly define the types of parameters and return values for functions and closures, providing clarity at the cost of verbosity." />
                    <Term value="type annotations" definition="Type annotations explicitly define the types of parameters and return values for functions and closures, providing clarity at the cost of verbosity." />
                    <Term value="Closure Type Inference" definition="The process by which the compiler deduces the types of the parameters and return value of a closure based on its usage context." />
                  </list>
                </value>
              </entry>
              <entry key="500489820">
                <value>
                  <list>
                    <Term value="Box&lt;dyn error::Error&gt;" definition="A catch-all error type in Rust used for error handling, but not recommended for library code due to the lack of specificity." />
                    <Term value="ParseIntError" definition="An error that can occur when attempting to parse a string into an integer." />
                    <Term value="map_err()" definition="A method in Rust's Result type that allows transforming one type of error into another." />
                  </list>
                </value>
              </entry>
              <entry key="500996998">
                <value>
                  <list>
                    <Term value="should_panic" definition="An attribute in Rust used in test functions to indicate that the test will pass if the code within it causes a panic, and fail otherwise." />
                    <Term value="panic!" definition="A macro in Rust that stops normal execution and begins unwinding the stack when called, often used to signify unrecoverable errors." />
                  </list>
                </value>
              </entry>
              <entry key="509091490">
                <value>
                  <list>
                    <Term value="Field Init Shorthand" definition="Field init shorthand in Rust is a syntax that helps reduce repetition when struct field names and parameter names are the same, allowing you to simply write the field name instead of `field_name: value_name`." />
                    <Term value="field init shorthand" definition="Field init shorthand in Rust is a syntax that helps reduce repetition when struct field names and parameter names are the same, allowing you to simply write the field name instead of `field_name: value_name`." />
                  </list>
                </value>
              </entry>
              <entry key="514899863">
                <value>
                  <list>
                    <Term value="Vec::new" definition="A function in Rust to create a new, empty vector." />
                    <Term value="Vec&lt;T&gt;" definition="A generic type in Rust's standard library representing a collection that can hold elements of any type specified within angle brackets." />
                  </list>
                </value>
              </entry>
              <entry key="520953256">
                <value>
                  <list>
                    <Term value="Trait Bound Syntax" definition="Trait Bound Syntax in Rust allows specifying constraints on generic type parameters, ensuring they implement specific traits required in the implementation." />
                    <Term value="std::fmt::Display" definition="std::fmt::Display is a trait in Rust used for formatting and printing values to a string or standard output in a user-friendly way." />
                  </list>
                </value>
              </entry>
              <entry key="523112973">
                <value>
                  <list>
                    <Term value="hash map" definition="A hash map is a data structure that implements an associative array or dictionary, which allows for the storage and retrieval of key-value pairs efficiently." />
                  </list>
                </value>
              </entry>
              <entry key="535993677">
                <value>
                  <list>
                    <Term value="Enum" definition="In programming, an Enum (short for enumeration) is a type that can contain multiple variants, each of which can have associated data of different types and amounts." />
                    <Term value="enum" definition="In programming, an Enum (short for enumeration) is a type that can contain multiple variants, each of which can have associated data of different types and amounts." />
                    <Term value="IpAddr" definition="In Rust, the `IpAddr` enum represents IP addresses and can have variants `V4` for IPv4 addresses and `V6` for IPv6 addresses, each holding associated data." />
                    <Term value="Ipv4Addr" definition="In Rust, `Ipv4Addr` is a struct that encapsulates data for IPv4 addresses." />
                    <Term value="Ipv6Addr" definition="In Rust, `Ipv6Addr` is a struct that encapsulates data for IPv6 addresses." />
                  </list>
                </value>
              </entry>
              <entry key="540756642">
                <value>
                  <list>
                    <Term value="Refactor" definition="Refactoring is the process of restructuring existing computer code without changing its external behavior." />
                    <Term value="refactoring" definition="Refactoring is the process of restructuring existing computer code without changing its external behavior." />
                    <Term value="Refactoring" definition="Refactoring is the process of restructuring existing computer code without changing its external behavior." />
                    <Term value="Extract Method" definition="Extract Method is a refactoring technique that involves moving a code fragment into a separate function to improve readability and reusability." />
                    <Term value="slice" definition="A slice in Rust refers to a dynamically-sized view into a contiguous sequence of elements, such as an array." />
                    <Term value="slices" definition="A slice in Rust refers to a dynamically-sized view into a contiguous sequence of elements, such as an array." />
                    <Term value="Vec&lt;i32&gt;" definition="Vec&lt;i32&gt; is a vector type in Rust that provides a dynamic array where each element is a 32-bit integer." />
                  </list>
                </value>
              </entry>
              <entry key="554988674">
                <value>
                  <list>
                    <Term value="Vec&lt;T&gt;" definition="A `Vec&lt;T&gt;` or vector is a collection type in Rust that allows you to store multiple values of the same type in a single data structure, with values placed next to each other in memory." />
                  </list>
                </value>
              </entry>
              <entry key="566586203">
                <value>
                  <list>
                    <Term value="move Closures" definition="A move closure in Rust forces the closure to take ownership of the values it uses in the environment rather than borrowing." />
                    <Term value="thread::spawn" definition="A function in Rust's standard library used to create a new thread and execute a closure in that thread." />
                    <Term value="ownership rules" definition="Rust's system of ensuring memory safety by enforcing strict ownership, borrowing, and lifetime rules." />
                  </list>
                </value>
              </entry>
              <entry key="567253858">
                <value>
                  <list>
                    <Term value="HashMap" definition="The type `HashMap&lt;K, V&gt;` stores a mapping of keys of type `K` to values of type `V` using a hashing function to determine how keys and values are placed into memory." />
                    <Term value="hashing function" definition="A hashing function is used to determine how keys and values are placed into memory in a hash map." />
                  </list>
                </value>
              </entry>
              <entry key="588857367">
                <value>
                  <list>
                    <Term value="Function-like macros" definition="Macros in Rust that look like function calls and are more flexible than functions. They can take an unknown number of arguments and process a `TokenStream` parameter with Rust code to generate results." />
                    <Term value="function-like macro" definition="Macros in Rust that look like function calls and are more flexible than functions. They can take an unknown number of arguments and process a `TokenStream` parameter with Rust code to generate results." />
                    <Term value="TokenStream" definition="A data structure in Rust used as input and output in procedural macros, representing a sequence of tokens that can be manipulated to generate code." />
                  </list>
                </value>
              </entry>
              <entry key="602362760">
                <value>
                  <list>
                    <Term value="HashMap" definition="A HashMap in Rust is a collection that stores key-value pairs and ensures unique keys for efficient data lookup." />
                    <Term value="Ownership" definition="Ownership in Rust is a system ensuring memory safety without a garbage collector, where a variable owns its data and when it goes out of scope, the data is cleaned up." />
                  </list>
                </value>
              </entry>
              <entry key="602393854">
                <value>
                  <list>
                    <Term value="mutable reference" definition="A mutable reference in programming allows a function to take a reference to a variable and modify its value without taking ownership of it." />
                    <Term value="array copying" definition="Array copying refers to creating a duplicate of an array's data instead of moving its ownership or passing a reference to it." />
                  </list>
                </value>
              </entry>
              <entry key="626830309">
                <value>
                  <list>
                    <Term value="unwrap" definition="A shortcut method for the Result&lt;T, E&gt; type in Rust. If the Result is Ok, it returns the value inside Ok; if it's Err, it calls the panic! macro." />
                    <Term value="expect" definition="A method similar to unwrap in Rust, but allows specifying a custom panic! error message, which can help in debugging by indicating the source of the panic." />
                  </list>
                </value>
              </entry>
              <entry key="641308811">
                <value>
                  <list>
                    <Term value="immutable references" definition="An immutable reference in Rust allows read-only access to data, without the ability to modify it." />
                    <Term value="immutable reference" definition="An immutable reference in Rust allows read-only access to data, without the ability to modify it." />
                  </list>
                </value>
              </entry>
              <entry key="676636196">
                <value>
                  <list>
                    <Term value="Boolean Type" definition="In Rust, a Boolean type has two possible values: true and false. It is specified using 'bool' and is one byte in size." />
                    <Term value="Boolean type" definition="In Rust, a Boolean type has two possible values: true and false. It is specified using 'bool' and is one byte in size." />
                  </list>
                </value>
              </entry>
              <entry key="677268551">
                <value>
                  <list>
                    <Term value="Structs" definition="In Rust, a Struct lets you create custom types that group associated pieces of data together and allows naming each piece to make the code clear." />
                    <Term value="structs" definition="In Rust, a Struct lets you create custom types that group associated pieces of data together and allows naming each piece to make the code clear." />
                    <Term value="struct" definition="In Rust, a Struct lets you create custom types that group associated pieces of data together and allows naming each piece to make the code clear." />
                    <Term value="Methods" definition="A Method in Rust specifies the behavior of instances of a struct." />
                    <Term value="associated functions" definition="An Associated function in Rust is a namespace functionality that pertains to a struct but does not require an instance of the struct." />
                    <Term value="enum" definition="Rust's Enum feature is another tool for creating custom types." />
                  </list>
                </value>
              </entry>
              <entry key="696225797">
                <value>
                  <list>
                    <Term value="Closures" definition="In Rust, a closure is an anonymous function that can capture values from the scope in which they are defined and can be saved in a variable or passed as arguments to other functions." />
                    <Term value="closures" definition="In Rust, a closure is an anonymous function that can capture values from the scope in which they are defined and can be saved in a variable or passed as arguments to other functions." />
                    <Term value="closure" definition="In Rust, a closure is an anonymous function that can capture values from the scope in which they are defined and can be saved in a variable or passed as arguments to other functions." />
                  </list>
                </value>
              </entry>
              <entry key="712621824">
                <value>
                  <list>
                    <Term value="Cargo.toml" definition="Cargo.toml is a configuration file for Rust projects where you can specify your project's dependencies, metadata, and other settings." />
                    <Term value="crate" definition="A Crate in Rust is a package of Rust code. It can be a library or an executable, and it's the primary unit of code packaging in Rust." />
                    <Term value="crates" definition="A Crate in Rust is a package of Rust code. It can be a library or an executable, and it's the primary unit of code packaging in Rust." />
                    <Term value="rand" definition="rand is an external Rust package used for generating random numbers." />
                    <Term value="thread_rng" definition="The thread_rng function in the rand crate provides a random number generator local to the current thread." />
                    <Term value="HashMap" definition="HashMap is a collection type in Rust's standard library (std) used to store key-value pairs." />
                  </list>
                </value>
              </entry>
              <entry key="718521888">
                <value>
                  <list>
                    <Term value="&amp;str" definition="The type for string slices in Rust, representing string data by reference." />
                  </list>
                </value>
              </entry>
              <entry key="726609420">
                <value>
                  <list>
                    <Term value="References" definition="In Rust, a reference, denoted by the `&amp;` symbol, allows you to refer to some value without taking ownership of it." />
                    <Term value="reference" definition="In Rust, a reference, denoted by the `&amp;` symbol, allows you to refer to some value without taking ownership of it." />
                    <Term value="references" definition="In Rust, a reference, denoted by the `&amp;` symbol, allows you to refer to some value without taking ownership of it." />
                    <Term value="referencing" definition="In Rust, a reference, denoted by the `&amp;` symbol, allows you to refer to some value without taking ownership of it." />
                    <Term value="dereferencing" definition="Dereferencing, accomplished with the `*` operator in Rust, is the opposite of referencing and allows access to the value a reference points to." />
                    <Term value="dereference" definition="Dereferencing, accomplished with the `*` operator in Rust, is the opposite of referencing and allows access to the value a reference points to." />
                    <Term value="Borrowing" definition="Borrowing in Rust refers to the ability to use a reference to a value without taking ownership of the value." />
                    <Term value="borrowing" definition="Borrowing in Rust refers to the ability to use a reference to a value without taking ownership of the value." />
                    <Term value="borrow" definition="Borrowing in Rust refers to the ability to use a reference to a value without taking ownership of the value." />
                  </list>
                </value>
              </entry>
              <entry key="737300040">
                <value>
                  <list>
                    <Term value="iterates" definition="In programming, to iterate means to go through each element of a collection, such as a list or array, one at a time." />
                    <Term value="variable" definition="A variable is a named storage that a program can use to store and retrieve values." />
                    <Term value="rust" definition="Rust is a programming language focused on safety, speed, and concurrency. It prevents memory errors like null pointer dereferencing and data races." />
                  </list>
                </value>
              </entry>
              <entry key="742053261">
                <value>
                  <list>
                    <Term value="pub Keyword" definition="In Rust, the `pub` keyword is used to make modules, structs, enums, functions, and methods public, allowing their use outside of their parent module." />
                    <Term value="pub keyword" definition="In Rust, the `pub` keyword is used to make modules, structs, enums, functions, and methods public, allowing their use outside of their parent module." />
                    <Term value="Absolute path" definition="In Rust, an absolute path starts from the crate root and uses the `crate` keyword to access a module or item from the top-level module hierarchy." />
                    <Term value="absolute path" definition="In Rust, an absolute path starts from the crate root and uses the `crate` keyword to access a module or item from the top-level module hierarchy." />
                    <Term value="Relative path" definition="In Rust, a relative path starts from the current module and allows access to other modules or items starting from the current module's location in the hierarchy." />
                    <Term value="relative path" definition="In Rust, a relative path starts from the current module and allows access to other modules or items starting from the current module's location in the hierarchy." />
                    <Term value="privacy rules" definition="In Rust, privacy rules determine access to modules, structs, enums, functions, and methods. By default, items are private and only accessible in the same module unless marked public with the `pub` keyword." />
                  </list>
                </value>
              </entry>
              <entry key="759957889">
                <value>
                  <list>
                    <Term value="Channels" definition="In Rust, channels are a means of communication between threads, where a sender transmits data to a receiver, ensuring safe data transfer and synchronization." />
                    <Term value="channels" definition="In Rust, channels are a means of communication between threads, where a sender transmits data to a receiver, ensuring safe data transfer and synchronization." />
                    <Term value="channel" definition="In Rust, channels are a means of communication between threads, where a sender transmits data to a receiver, ensuring safe data transfer and synchronization." />
                    <Term value="ownership rules" definition="Ownership rules in Rust help ensure safe, concurrent code by preventing data races, ensuring that values can't be used after they've been moved or transferred." />
                    <Term value="borrow of moved value" definition="Occurs in Rust when an attempt is made to use a value after its ownership has been moved, leading to a compile-time error that prevents unsafe usage." />
                  </list>
                </value>
              </entry>
              <entry key="767484406">
                <value>
                  <list>
                    <Term value="ownership" definition="In Rust, ownership is a system designed to manage memory. Each value in Rust has a variable that's called its owner, and there is only one owner at a time." />
                    <Term value="Ownership" definition="In Rust, ownership is a system designed to manage memory. Each value in Rust has a variable that's called its owner, and there is only one owner at a time." />
                    <Term value="Scope" definition="In Rust, scope refers to the context within which a variable is valid and can be used." />
                    <Term value="scope" definition="In Rust, scope refers to the context within which a variable is valid and can be used." />
                    <Term value="dropped" definition="In Rust, `drop` is a function that is automatically called when a variable goes out of scope to clean up memory." />
                    <Term value="drop" definition="In Rust, `drop` is a function that is automatically called when a variable goes out of scope to clean up memory." />
                  </list>
                </value>
              </entry>
              <entry key="798112871">
                <value>
                  <list>
                    <Term value="panic!" definition="In Rust, `panic!` is a macro that stops execution and exits when an unrecoverable error occurs, such as accessing an out-of-bounds index in a vector." />
                    <Term value="RUST_BACKTRACE" definition="An environment variable in Rust that is set to generate a backtrace, which is a list of all the functions called leading to a specific point in the program." />
                    <Term value="buffer overread" definition="A security vulnerability where a program reads memory outside of the bounds of a buffer, potentially exposing sensitive data." />
                    <Term value="debug symbols" definition="Additional information included in the build of a program, used to assist debugging by providing detailed stack traces when encountering errors like `panic!`." />
                    <Term value="Debug symbols" definition="Additional information included in the build of a program, used to assist debugging by providing detailed stack traces when encountering errors like `panic!`." />
                  </list>
                </value>
              </entry>
              <entry key="809403826">
                <value>
                  <list>
                    <Term value="Iterator" definition="The `Iterator` trait in Rust provides a way to iterate through a series of items. Implementing the `next` method is required when creating a custom iterator." />
                    <Term value="iterator" definition="The `Iterator` trait in Rust provides a way to iterate through a series of items. Implementing the `next` method is required when creating a custom iterator." />
                    <Term value="sum method" definition="In Rust, the `sum` method is a consuming adaptor of the `Iterator` trait that iterates through items, takes ownership of the iterator, and calculates the total of all items." />
                    <Term value="consuming adaptors" definition="Consuming adaptors in Rust are methods of the `Iterator` trait, such as `sum`, that take ownership of the iterator and utilize it by repeatedly calling the `next` method until the iterator is consumed." />
                  </list>
                </value>
              </entry>
              <entry key="811789983">
                <value>
                  <list>
                    <Term value="Generic Type Parameters" definition="Generic Type Parameters allow functions, structs, enums, or traits to operate on many different types while still being type-safe." />
                    <Term value="generic type parameters" definition="Generic Type Parameters allow functions, structs, enums, or traits to operate on many different types while still being type-safe." />
                    <Term value="generic type parameter" definition="Generic Type Parameters allow functions, structs, enums, or traits to operate on many different types while still being type-safe." />
                    <Term value="Trait Bounds" definition="Trait Bounds specify that a generic type must implement a particular trait, enabling specific behavior for the generic type." />
                    <Term value="Display" definition="The Display trait in Rust is used to format a type as a user-facing string by implementing the fmt::Display trait." />
                    <Term value="Lifetimes" definition="Lifetimes in Rust specify how long references are valid, ensuring memory safety by preventing dangling references." />
                    <Term value="lifetimes" definition="Lifetimes in Rust specify how long references are valid, ensuring memory safety by preventing dangling references." />
                    <Term value="lifetime" definition="Lifetimes in Rust specify how long references are valid, ensuring memory safety by preventing dangling references." />
                  </list>
                </value>
              </entry>
              <entry key="817483318">
                <value>
                  <list>
                    <Term value="generics" definition="Generics in programming allow functions, data structures, or algorithms to operate with any data type while maintaining type safety, helping to eliminate code duplication." />
                    <Term value="generic" definition="Generics in programming allow functions, data structures, or algorithms to operate with any data type while maintaining type safety, helping to eliminate code duplication." />
                  </list>
                </value>
              </entry>
              <entry key="817935296">
                <value>
                  <list>
                    <Term value="TryFrom" definition="TryFrom is a simple and safe type conversion in Rust that may fail in a controlled way under some circumstances, returning a Result type instead of the target type itself." />
                    <Term value="Result" definition="In Rust, Result is an enum used for error handling that represents either success (Ok) or failure (Err)." />
                    <Term value="result" definition="In Rust, Result is an enum used for error handling that represents either success (Ok) or failure (Err)." />
                  </list>
                </value>
              </entry>
              <entry key="830300035">
                <value>
                  <list>
                    <Term value="Generic" definition="Generics in Rust are abstract stand-ins for concrete types or other properties, allowing code to express behavior and relationships without knowing the specific types at compile or runtime." />
                    <Term value="generics" definition="Generics in Rust are abstract stand-ins for concrete types or other properties, allowing code to express behavior and relationships without knowing the specific types at compile or runtime." />
                    <Term value="Generics" definition="Generics in Rust are abstract stand-ins for concrete types or other properties, allowing code to express behavior and relationships without knowing the specific types at compile or runtime." />
                    <Term value="generic" definition="Generics in Rust are abstract stand-ins for concrete types or other properties, allowing code to express behavior and relationships without knowing the specific types at compile or runtime." />
                    <Term value="Traits" definition="Traits in Rust define behavior in a generic way and can be combined with generic types to constrain a type to only those that have a particular behavior." />
                    <Term value="traits" definition="Traits in Rust define behavior in a generic way and can be combined with generic types to constrain a type to only those that have a particular behavior." />
                    <Term value="Lifetimes" definition="Lifetimes in Rust provide the compiler with information about how references relate to each other, enabling safe borrowing of values while ensuring references are valid." />
                    <Term value="lifetimes" definition="Lifetimes in Rust provide the compiler with information about how references relate to each other, enabling safe borrowing of values while ensuring references are valid." />
                  </list>
                </value>
              </entry>
              <entry key="871495868">
                <value>
                  <list>
                    <Term value="mpsc::channel" definition="A function in Rust's standard library used for creating a channel for message passing, with mpsc standing for 'multiple producer, single consumer'." />
                    <Term value="thread::spawn" definition="A function in Rust used to create a new thread for concurrent execution." />
                    <Term value="thread::sleep" definition="A function in Rust that pauses the execution of the current thread for a specified duration." />
                    <Term value="Duration::from_secs" definition="A function in Rust used to create a `Duration` object representing a span of time in seconds." />
                  </list>
                </value>
              </entry>
              <entry key="893902885">
                <value>
                  <list>
                    <Term value="Option&lt;T&gt;" definition="Option&lt;T&gt; is an enum in Rust used to represent a value that can either be present (Some) or not present (None)." />
                    <Term value="unwrap" definition="Unwrap is a method in Rust used to extract the value inside an Option&lt;T&gt;. It can cause a panic if the Option&lt;T&gt; is None." />
                    <Term value="Unwrapping" definition="Unwrap is a method in Rust used to extract the value inside an Option&lt;T&gt;. It can cause a panic if the Option&lt;T&gt; is None." />
                    <Term value="pattern match" definition="Pattern match in Rust is a way to safely extract the value within an Option&lt;T&gt; using match expressions to handle both Some and None cases." />
                  </list>
                </value>
              </entry>
              <entry key="921255735">
                <value>
                  <list>
                    <Term value="Mutex" definition="Mutex is an abbreviation for mutual exclusion, allowing only one thread to access some data at any given time by acquiring its lock." />
                    <Term value="mutex" definition="Mutex is an abbreviation for mutual exclusion, allowing only one thread to access some data at any given time by acquiring its lock." />
                    <Term value="lock" definition="The lock is a data structure that is part of the mutex that keeps track of who currently has exclusive access to the data." />
                    <Term value="locking" definition="The lock is a data structure that is part of the mutex that keeps track of who currently has exclusive access to the data." />
                  </list>
                </value>
              </entry>
              <entry key="943747377">
                <value>
                  <list>
                    <Term value="Closures" definition="In Rust, a Closure is an anonymous function that can capture values from the surrounding scope using borrowing immutably, borrowing mutably, or taking ownership." />
                    <Term value="closure" definition="In Rust, a Closure is an anonymous function that can capture values from the surrounding scope using borrowing immutably, borrowing mutably, or taking ownership." />
                    <Term value="closures" definition="In Rust, a Closure is an anonymous function that can capture values from the surrounding scope using borrowing immutably, borrowing mutably, or taking ownership." />
                    <Term value="immutable borrow" definition="An Immutable Borrow in Rust allows a function or closure to access a variable without taking ownership, ensuring the variable cannot be modified while borrowed." />
                    <Term value="immutable borrows" definition="An Immutable Borrow in Rust allows a function or closure to access a variable without taking ownership, ensuring the variable cannot be modified while borrowed." />
                    <Term value="mutable borrow" definition="A Mutable Borrow in Rust allows a function or closure to access and modify a variable, but prohibits any other borrow of the variable during this time." />
                  </list>
                </value>
              </entry>
              <entry key="958003439">
                <value>
                  <list>
                    <Term value="Iterator Trait" definition="The `Iterator` trait in Rust is a trait defined in the standard library that requires implementors to define the `next` method, which returns one item of the iterator at a time wrapped in `Some` and returns `None` when iteration is over." />
                    <Term value="next Method" definition="The `next` method in Rust is a required method of the `Iterator` trait that returns an item from the iterator wrapped in `Some` and returns `None` when the iteration is complete." />
                    <Term value="next method" definition="The `next` method in Rust is a required method of the `Iterator` trait that returns an item from the iterator wrapped in `Some` and returns `None` when the iteration is complete." />
                  </list>
                </value>
              </entry>
              <entry key="972892025">
                <value>
                  <list>
                    <Term value="lifetimes" definition="In Rust, a Lifetime ensures that the data referenced by a structure or variable is valid for as long as it is needed, preventing dangling references." />
                    <Term value="Lifetime" definition="In Rust, a Lifetime ensures that the data referenced by a structure or variable is valid for as long as it is needed, preventing dangling references." />
                    <Term value="Lifetimes" definition="In Rust, a Lifetime ensures that the data referenced by a structure or variable is valid for as long as it is needed, preventing dangling references." />
                    <Term value="lifetime" definition="In Rust, a Lifetime ensures that the data referenced by a structure or variable is valid for as long as it is needed, preventing dangling references." />
                    <Term value="references" definition="In Rust, a reference is a pointer to data owned by another variable, denoted by `&amp;`, allowing access without taking ownership." />
                    <Term value="referenced" definition="In Rust, a reference is a pointer to data owned by another variable, denoted by `&amp;`, allowing access without taking ownership." />
                    <Term value="reference" definition="In Rust, a reference is a pointer to data owned by another variable, denoted by `&amp;`, allowing access without taking ownership." />
                  </list>
                </value>
              </entry>
              <entry key="974020808">
                <value>
                  <list>
                    <Term value="recv" definition="In Rust, `recv` is a method on the receiving end of a channel that blocks the main thread's execution and waits until a value is sent down the channel. It returns the value as a `Result&lt;T, E&gt;` or an error if the sending end is closed." />
                    <Term value="try_recv" definition="In Rust, `try_recv` is a method on the receiving end of a channel that returns a `Result&lt;T, E&gt;` immediately without blocking. It provides an `Ok` value holding a message if available or an `Err` if no messages are currently available." />
                  </list>
                </value>
              </entry>
              <entry key="995237923">
                <value>
                  <list>
                    <Term value="Borrow" definition="In programming with Rust, borrowing allows a function to use a variable without taking ownership of it, achieved by passing the variable's reference." />
                    <Term value="borrowing" definition="In programming with Rust, borrowing allows a function to use a variable without taking ownership of it, achieved by passing the variable's reference." />
                    <Term value="ownership" definition="In Rust, ownership is a system ensuring memory safety by managing how data is accessed, passed, or transferred between functions and variables." />
                  </list>
                </value>
              </entry>
              <entry key="1003947841">
                <value>
                  <list>
                    <Term value="Modules" definition="In Rust, a Module is a way to organize code within a crate into groups for readability and reuse, and to control the privacy of items." />
                    <Term value="modules" definition="In Rust, a Module is a way to organize code within a crate into groups for readability and reuse, and to control the privacy of items." />
                    <Term value="module" definition="In Rust, a Module is a way to organize code within a crate into groups for readability and reuse, and to control the privacy of items." />
                    <Term value="crate roots" definition="In Rust, the contents of src/main.rs or src/lib.rs form a module named crate at the root of the crate’s module structure, known as the module tree." />
                    <Term value="module tree" definition="In Rust, a Module tree is the hierarchical structure of modules within a crate, showing how modules are nested with parents, children, and siblings." />
                  </list>
                </value>
              </entry>
              <entry key="1005120038">
                <value>
                  <list>
                    <Term value="Closures" definition="A closure in programming is a function that can capture and use values from the scope in which it is defined." />
                    <Term value="closures" definition="A closure in programming is a function that can capture and use values from the scope in which it is defined." />
                    <Term value="closure" definition="A closure in programming is a function that can capture and use values from the scope in which it is defined." />
                    <Term value="unwrap_or_else" definition="The unwrap_or_else method on Option&lt;T&gt; in Rust calls a closure to provide a value when the Option is None, or returns the value within the Some variant directly." />
                    <Term value="ShirtColor" definition="An enum in Rust called ShirtColor that represents two variants: Red and Blue." />
                    <Term value="most_stocked" definition="In this context, the most_stocked method of Inventory calculates which shirt color has the highest number in stock and returns it." />
                  </list>
                </value>
              </entry>
              <entry key="1008215558">
                <value>
                  <list>
                    <Term value="Unwinding the Stack" definition="Unwinding involves Rust walking back up the stack and cleaning up the data from each function it encounters when a panic occurs." />
                    <Term value="panic = 'abort'" definition="A setting in Rust's Cargo.toml file that makes the program immediately abort without cleaning up when a panic occurs, to generate smaller binaries." />
                    <Term value="Cargo.toml" definition="A configuration file in Rust projects where settings, such as `panic = 'abort'`, can be specified for different build profiles." />
                    <Term value="backtrace" definition="A backtrace in Rust provides the sequence of function calls leading to a `panic!` call, helping to locate the part of the code causing the problem." />
                  </list>
                </value>
              </entry>
              <entry key="1017917019">
                <value>
                  <list>
                    <Term value="Ownership" definition="In Rust, Ownership is a set of rules that governs how a program manages memory, determining when variables are valid and when memory is freed." />
                    <Term value="ownership" definition="In Rust, Ownership is a set of rules that governs how a program manages memory, determining when variables are valid and when memory is freed." />
                    <Term value="scope" definition="Scope in Rust refers to the region within the code where a variable is valid and can be used." />
                    <Term value="move" definition="In Rust, a move occurs when ownership of a value is transferred from one variable to another, making the original variable invalid." />
                    <Term value="moves" definition="In Rust, a move occurs when ownership of a value is transferred from one variable to another, making the original variable invalid." />
                    <Term value="moved" definition="In Rust, a move occurs when ownership of a value is transferred from one variable to another, making the original variable invalid." />
                    <Term value="copy" definition="In Rust, types that implement the `Copy` trait can be duplicated without moving ownership, allowing values to remain usable after assignment or function calls." />
                    <Term value="Copy" definition="In Rust, types that implement the `Copy` trait can be duplicated without moving ownership, allowing values to remain usable after assignment or function calls." />
                  </list>
                </value>
              </entry>
              <entry key="1032215800">
                <value>
                  <list>
                    <Term value="structs" definition="A struct is a user-defined data type in Rust that groups related data together to form a complex data type, enhancing manageability and readability." />
                    <Term value="Cargo" definition="Cargo is Rust's build system and package manager, used to create, build, and manage Rust projects." />
                    <Term value="cargo" definition="Cargo is Rust's build system and package manager, used to create, build, and manage Rust projects." />
                    <Term value="Tuple" definition="A tuple is a compound data type in Rust that allows grouping of multiple values with different types into a single value." />
                  </list>
                </value>
              </entry>
              <entry key="1052050764">
                <value>
                  <list>
                    <Term value="Cow" definition="A clone-on-write smart pointer in Rust that provides immutable access to borrowed data and clones the data lazily when mutation or ownership is required." />
                    <Term value="Cow::Borrowed" definition="A variant of the `Cow` type indicating the data is borrowed and does not require cloning." />
                    <Term value="Cow::Owned" definition="A variant of the `Cow` type indicating the data is owned and has been cloned or was originally owned." />
                  </list>
                </value>
              </entry>
              <entry key="1062999995">
                <value>
                  <list>
                    <Term value="Vector" definition="In Rust, a Vector is a growable array-like data structure used to store a contiguous sequence of elements." />
                    <Term value="vector" definition="In Rust, a Vector is a growable array-like data structure used to store a contiguous sequence of elements." />
                    <Term value="scope" definition="In Rust, scope defines the lifetime of variables, and when a variable goes out of scope, it is automatically dropped and its memory is freed." />
                  </list>
                </value>
              </entry>
              <entry key="1063411002">
                <value>
                  <list>
                    <Term value="Library Crate" definition="In Rust, a Library Crate is a package that contains library code which can be shared and reused in multiple projects." />
                    <Term value="library crate" definition="In Rust, a Library Crate is a package that contains library code which can be shared and reused in multiple projects." />
                    <Term value="trait" definition="In Rust, a Trait is a collection of methods that are defined for an unknown type which can then be implemented by structs or enums." />
                    <Term value="macro" definition="In Rust, a Macro is a way of writing code that writes other code, allowing for metaprogramming. It's often used to generate code at compile time." />
                    <Term value="Macro" definition="In Rust, a Macro is a way of writing code that writes other code, allowing for metaprogramming. It's often used to generate code at compile time." />
                    <Term value="reflection" definition="In programming, Reflection refers to the ability of a program to inspect and manipulate its own structure and behavior at runtime. Rust does not have reflection capabilities." />
                  </list>
                </value>
              </entry>
              <entry key="1082489777">
                <value>
                  <list>
                    <Term value="Mutable Variable Binding" definition="In Rust, variable bindings are immutable by default, but they can be made mutable with a specific keyword." />
                  </list>
                </value>
              </entry>
              <entry key="1088634202">
                <value>
                  <list>
                    <Term value="Move" definition="In Rust, a 'Move' refers to transferring ownership of a value from one variable to another. When this happens, the original variable is invalidated to ensure memory safety." />
                    <Term value="moved" definition="In Rust, a 'Move' refers to transferring ownership of a value from one variable to another. When this happens, the original variable is invalidated to ensure memory safety." />
                    <Term value="move" definition="In Rust, a 'Move' refers to transferring ownership of a value from one variable to another. When this happens, the original variable is invalidated to ensure memory safety." />
                    <Term value="shallow copy" definition="A Shallow Copy in programming means copying only the reference to a data structure, rather than duplicating its contents. In Rust, this is called a 'Move' as the original variable becomes invalid." />
                    <Term value="deep copy" definition="A Deep Copy involves duplicating all levels of data, including heap data, which requires more computational resources. Rust does not automatically create deep copies for performance reasons." />
                  </list>
                </value>
              </entry>
              <entry key="1104571135">
                <value>
                  <list>
                    <Term value="unit tests" definition="Unit tests are small and more focused, testing one module in isolation at a time, and can test private interfaces." />
                    <Term value="Unit tests" definition="Unit tests are small and more focused, testing one module in isolation at a time, and can test private interfaces." />
                    <Term value="integration tests" definition="Integration tests are entirely external to your library and use your code in the same way any other external code would, using only the public interface and potentially exercising multiple modules per test." />
                    <Term value="Integration tests" definition="Integration tests are entirely external to your library and use your code in the same way any other external code would, using only the public interface and potentially exercising multiple modules per test." />
                  </list>
                </value>
              </entry>
              <entry key="1122471425">
                <value>
                  <list>
                    <Term value="entry()" definition="A method in Rust's HashMap that allows you to work with an entry in the map corresponding to a specific key, whether it's present or not." />
                    <Term value="or_insert()" definition="A method in Rust's HashMap that inserts a value for the key if the key does not exist, or retrieves the existing value." />
                  </list>
                </value>
              </entry>
              <entry key="1158989440">
                <value>
                  <list>
                    <Term value="enum" definition="In Rust, an Enum is a type that can represent one of several different possible values, each of which may carry additional data." />
                    <Term value="struct" definition="A Struct in Rust is a custom data type that groups related data together and can have named or unnamed fields." />
                    <Term value="structs" definition="A Struct in Rust is a custom data type that groups related data together and can have named or unnamed fields." />
                    <Term value="impl" definition="In Rust, `impl` is used to define implementations of methods for structs, enums, or traits." />
                  </list>
                </value>
              </entry>
              <entry key="1170207296">
                <value>
                  <list>
                    <Term value="Enum" definition="In Rust, an Enum allows you to define a type that can hold multiple variants, where each variant can store data of a specific type." />
                    <Term value="enum" definition="In Rust, an Enum allows you to define a type that can hold multiple variants, where each variant can store data of a specific type." />
                    <Term value="SpreadsheetCell" definition="In Rust, SpreadsheetCell is an example of an Enum defined to store different types such as integers, floating-point numbers, and strings within a single vector." />
                    <Term value="Vec&lt;T&gt;" definition="In Rust, Vec&lt;T&gt; is a growable vector type provided by the standard library used for storing elements of the same data type on the heap." />
                  </list>
                </value>
              </entry>
              <entry key="1178252390">
                <value>
                  <list>
                    <Term value="HashMap" definition="In Rust, a HashMap is a collection that maps keys to values. Each key can only have one associated value, but keys and values can be updated, inserted, or replaced." />
                    <Term value="or_insert" definition="In Rust HashMap, the `or_insert` method is used with the `entry` API to insert a new value if the key doesn't already exist, or return a mutable reference to the existing value." />
                  </list>
                </value>
              </entry>
              <entry key="1182204989">
                <value>
                  <list>
                    <Term value="String::from" definition="In Rust, `String::from` is used to create a new `String` from a string literal." />
                    <Term value="String::push_str" definition="In Rust, `String::push_str` is a method used to append a string slice to a `String`." />
                  </list>
                </value>
              </entry>
              <entry key="1187875855">
                <value>
                  <list>
                    <Term value="Option&lt;T&gt;" definition="Option&lt;T&gt; is an enum in Rust that is generic over type T, with two variants: Some, which holds a value of type T, and None, which holds no value. It represents an optional value for any type." />
                    <Term value="Result&lt;T, E&gt;" definition="Result&lt;T, E&gt; is an enum in Rust that is generic over two types: T and E. It has two variants: Ok, which holds a value of type T, and Err, which holds a value of type E. It is used to represent the outcome of an operation that may succeed or fail." />
                  </list>
                </value>
              </entry>
              <entry key="1206777257">
                <value>
                  <list>
                    <Term value="Vector" definition="In programming, a Vector is a dynamic array that can change its size when elements are added or removed." />
                    <Term value="tuple" definition="A Tuple is a data structure that can hold a fixed number of elements, often of different types, grouped together." />
                  </list>
                </value>
              </entry>
              <entry key="1207641964">
                <value>
                  <list>
                    <Term value="Clippy" definition="Clippy is a tool in Rust that provides a collection of lints to analyze your code, helping you catch common mistakes and improve your Rust code." />
                    <Term value="clippy" definition="Clippy is a tool in Rust that provides a collection of lints to analyze your code, helping you catch common mistakes and improve your Rust code." />
                    <Term value="std::f32::consts" definition="In Rust, std::f32::consts contains the highest precision version of long or infinite precision mathematical constants within the standard library." />
                  </list>
                </value>
              </entry>
              <entry key="1211407258">
                <value>
                  <list>
                    <Term value="Macros" definition="Macros are constructs in programming that write code during compilation (metaprogramming). They differ from functions by taking a variable number of parameters and being expanded before compilation rather than executed at runtime." />
                    <Term value="macros" definition="Macros are constructs in programming that write code during compilation (metaprogramming). They differ from functions by taking a variable number of parameters and being expanded before compilation rather than executed at runtime." />
                    <Term value="macro" definition="Macros are constructs in programming that write code during compilation (metaprogramming). They differ from functions by taking a variable number of parameters and being expanded before compilation rather than executed at runtime." />
                    <Term value="Functions" definition="Functions are reusable blocks of code in programming that require a defined number and type of parameters and execute at runtime, unlike macros which are handled during compilation." />
                    <Term value="functions" definition="Functions are reusable blocks of code in programming that require a defined number and type of parameters and execute at runtime, unlike macros which are handled during compilation." />
                    <Term value="function" definition="Functions are reusable blocks of code in programming that require a defined number and type of parameters and execute at runtime, unlike macros which are handled during compilation." />
                    <Term value="metaprogramming" definition="Metaprogramming refers to writing code that writes or manipulates other code, often used to reduce the amount of code developers need to write manually." />
                    <Term value="Metaprogramming" definition="Metaprogramming refers to writing code that writes or manipulates other code, often used to reduce the amount of code developers need to write manually." />
                  </list>
                </value>
              </entry>
              <entry key="1226511802">
                <value>
                  <list>
                    <Term value="Lifetimes" definition="In Rust, lifetimes are a way to specify how long a reference is valid to ensure references do not outlive the data they point to." />
                    <Term value="references" definition="In Rust, references are borrows that allow access to data without taking ownership." />
                    <Term value="reference" definition="In Rust, references are borrows that allow access to data without taking ownership." />
                  </list>
                </value>
              </entry>
              <entry key="1229838964">
                <value>
                  <list>
                    <Term value="Generics" definition="Generics allow for the creation of functions, data types, or other structures to operate across different data types while maintaining type safety." />
                    <Term value="generics" definition="Generics allow for the creation of functions, data types, or other structures to operate across different data types while maintaining type safety." />
                    <Term value="Vectors" definition="In Rust, a Vector is a dynamically sized array that can store multiple values of the same type; it is defined with generics to allow type specification." />
                    <Term value="vector" definition="In Rust, a Vector is a dynamically sized array that can store multiple values of the same type; it is defined with generics to allow type specification." />
                  </list>
                </value>
              </entry>
              <entry key="1233134621">
                <value>
                  <list>
                    <Term value="`?` Operator" definition="The `?` operator in Rust can only be used in functions that return `Result`, `Option`, or another type implementing `std::ops::Try`. It propagates errors by returning early if the value is an error." />
                    <Term value="`?` operator" definition="The `?` operator in Rust can only be used in functions that return `Result`, `Option`, or another type implementing `std::ops::Try`. It propagates errors by returning early if the value is an error." />
                    <Term value="Result" definition="`Result` is an enum in Rust used for functions that might return an error. It can be either `Ok(T)` representing a success or `Err(E)` representing an error." />
                    <Term value="Box&lt;dyn Error&gt;" definition="`Box&lt;dyn Error&gt;` in Rust is a trait object used to represent any kind of error. It allows grouping different error types under one umbrella for easier error handling." />
                  </list>
                </value>
              </entry>
              <entry key="1238203014">
                <value>
                  <list>
                    <Term value="DeMorgan's law" definition="DeMorgan's law provides a way to simplify logical expressions by transforming AND operations into OR operations and vice versa, often used in conditions optimization." />
                    <Term value="short-circuiting logical operators" definition="Short-circuiting logical operators like '&amp;&amp;' and '||' stop evaluating as soon as the result is determined." />
                  </list>
                </value>
              </entry>
              <entry key="1247971863">
                <value>
                  <list>
                    <Term value="type cast expression" definition="A simple form of type conversion in Rust, denoted with the binary operator `as`, used to convert a value of one type into another." />
                  </list>
                </value>
              </entry>
              <entry key="1251966206">
                <value>
                  <list>
                    <Term value="generics" definition="Generics allow code to operate on abstract types instead of specific ones, reducing code duplication by enabling a single function to handle different data types." />
                    <Term value="slice" definition="In Rust, a slice is a dynamically-sized view into a contiguous sequence of elements, allowing functions to operate on parts of an array or vector." />
                  </list>
                </value>
              </entry>
              <entry key="1263873041">
                <value>
                  <list>
                    <Term value="self" definition="In Rust, self is a special keyword used as the first parameter in a method signature within an impl block to refer to the instance of the type the method is being called on." />
                    <Term value="&amp;self" definition="In Rust, &amp;self represents an immutable reference to the calling instance of the type within a method, allowing only read access to the instance inside the method." />
                    <Term value="&amp;mut self" definition="In Rust, &amp;mut self represents a mutable reference to the calling instance of the type within a method, allowing the method to modify the data of the instance." />
                    <Term value="method syntax" definition="In Rust, method syntax allows invoking methods on a struct instance using dot notation, followed by the method name and parentheses." />
                    <Term value="automatic referencing and dereferencing" definition="In Rust, automatic referencing and dereferencing refers to the feature where Rust automatically adjusts references (e.g., adding &amp; or &amp;mut) when calling methods, so that the instance matches the method's signature." />
                  </list>
                </value>
              </entry>
              <entry key="1278020830">
                <value>
                  <list>
                    <Term value="String slices" definition="A slice that is specific to strings, allowing you to refer to a part of a string." />
                    <Term value="string slices" definition="A slice that is specific to strings, allowing you to refer to a part of a string." />
                  </list>
                </value>
              </entry>
              <entry key="1278934357">
                <value>
                  <list>
                    <Term value="map_err()" definition="A function in Rust used to map a lower-level error into a custom error type by providing a mapping closure." />
                  </list>
                </value>
              </entry>
              <entry key="1280981416">
                <value>
                  <list>
                    <Term value="Box" definition="In Rust, a Box is a smart pointer used to allocate data on the heap, enabling the storage of recursive types." />
                    <Term value="cons list" definition="A cons list is a recursive data structure frequently found in functional programming languages, where each item contains a value and a pointer to the next item, with the last item being a value called Nil." />
                    <Term value="cons lists" definition="A cons list is a recursive data structure frequently found in functional programming languages, where each item contains a value and a pointer to the next item, with the last item being a value called Nil." />
                  </list>
                </value>
              </entry>
              <entry key="1287727310">
                <value>
                  <list>
                    <Term value="Tuple" definition="A tuple is a general way of grouping together a number of values with a variety of types into one compound type. Tuples have a fixed length: once declared, they cannot grow or shrink in size." />
                    <Term value="tuple" definition="A tuple is a general way of grouping together a number of values with a variety of types into one compound type. Tuples have a fixed length: once declared, they cannot grow or shrink in size." />
                  </list>
                </value>
              </entry>
              <entry key="1319742354">
                <value>
                  <list>
                    <Term value="From trait" definition="The From trait is used for value-to-value conversions in Rust. If implemented correctly, the Into trait works conversely." />
                    <Term value="Default trait" definition="The Default trait in Rust is implemented to provide a fallback value for a type when no specific value is available." />
                    <Term value="parse::&lt;usize&gt;()" definition="The parse::&lt;usize&gt;() method in Rust converts a string into a usize type, handling parsing operations." />
                  </list>
                </value>
              </entry>
              <entry key="1320752604">
                <value>
                  <list>
                    <Term value="JoinHandle" definition="A JoinHandle is an owned value in Rust, and calling the join method on it will block the currently running thread until the thread represented by the handle finishes executing." />
                  </list>
                </value>
              </entry>
              <entry key="1322962627">
                <value>
                  <list>
                    <Term value="SpreadsheetCell" definition="A type representing cell values in a spreadsheet, used in the example to count cells by their type." />
                    <Term value="CellsCounter" definition="A struct used to store the results of counting cell types in a spreadsheet." />
                  </list>
                </value>
              </entry>
              <entry key="1328927593">
                <value>
                  <list>
                    <Term value="char" definition="In Rust, the `char` type is a four-byte type that represents a Unicode Scalar Value, allowing it to represent more than just ASCII, including emoji, accented letters, and other characters." />
                    <Term value="Unicode Scalar Value" definition="Unicode Scalar Values range from U+0000 to U+D7FF and U+E000 to U+10FFFF inclusive, representing a more extensive set of characters such as emoji and various scripts." />
                    <Term value="Unicode Scalar Values" definition="Unicode Scalar Values range from U+0000 to U+D7FF and U+E000 to U+10FFFF inclusive, representing a more extensive set of characters such as emoji and various scripts." />
                  </list>
                </value>
              </entry>
              <entry key="1339655377">
                <value>
                  <list>
                    <Term value="Lifetime Annotations" definition="In Rust, a lifetime annotation defines the scope for which a reference is valid." />
                    <Term value="lifetime annotations" definition="In Rust, a lifetime annotation defines the scope for which a reference is valid." />
                    <Term value="lifetime elision rules" definition="In Rust, lifetime elision rules allow the compiler to infer lifetimes in certain situations, simplifying code by avoiding explicit annotations." />
                    <Term value="lifetime elision rule" definition="In Rust, lifetime elision rules allow the compiler to infer lifetimes in certain situations, simplifying code by avoiding explicit annotations." />
                    <Term value="impl" definition="In Rust, `impl` is used to implement methods for structs, enums, or traits." />
                    <Term value="ImportantExcerpt" definition="A struct in Rust used as an example to demonstrate lifetimes and methods." />
                    <Term value="self" definition="In Rust, `self` is used to refer to the instance of the struct within its methods." />
                  </list>
                </value>
              </entry>
              <entry key="1342026890">
                <value>
                  <list>
                    <Term value="Lifetime Annotation" definition="Lifetime annotations describe the relationships of the lifetimes of multiple references to each other without affecting the lifetimes." />
                    <Term value="Lifetime annotations" definition="Lifetime annotations describe the relationships of the lifetimes of multiple references to each other without affecting the lifetimes." />
                    <Term value="lifetime annotation" definition="Lifetime annotations describe the relationships of the lifetimes of multiple references to each other without affecting the lifetimes." />
                    <Term value="lifetime annotations" definition="Lifetime annotations describe the relationships of the lifetimes of multiple references to each other without affecting the lifetimes." />
                    <Term value="lifetime parameter" definition="The names of lifetime parameters must start with an apostrophe (`'`) and are usually all lowercase and very short. They are placed after the `&amp;` of a reference, using a space to separate the annotation from the reference’s type." />
                    <Term value="lifetime parameters" definition="The names of lifetime parameters must start with an apostrophe (`'`) and are usually all lowercase and very short. They are placed after the `&amp;` of a reference, using a space to separate the annotation from the reference’s type." />
                  </list>
                </value>
              </entry>
              <entry key="1360966972">
                <value>
                  <list>
                    <Term value="Enum" definition="An Enum in programming is a data type that can have one of a predefined set of values, which are called variants. It is particularly useful for cases where a value can only be one of several options." />
                    <Term value="enum" definition="An Enum in programming is a data type that can have one of a predefined set of values, which are called variants. It is particularly useful for cases where a value can only be one of several options." />
                    <Term value="IpAddrKind" definition="IpAddrKind is a custom enumeration in Rust that represents the kinds of IP addresses, with two possible variants: V4 and V6." />
                    <Term value="variants" definition="Variants are the possible values of an Enum. In the case of IpAddrKind, the variants are V4 and V6." />
                    <Term value="variant" definition="Variants are the possible values of an Enum. In the case of IpAddrKind, the variants are V4 and V6." />
                  </list>
                </value>
              </entry>
              <entry key="1363000490">
                <value>
                  <list>
                    <Term value="Classic Struct" definition="A struct in programming with named fields such as 'name' and 'hex' for organizing data." />
                    <Term value="Tuple Struct" definition="A struct with unnamed fields, used to encapsulate multiple data values such as strings, integers, or other types." />
                    <Term value="tuple structs" definition="A struct with unnamed fields, used to encapsulate multiple data values such as strings, integers, or other types." />
                  </list>
                </value>
              </entry>
              <entry key="1366760111">
                <value>
                  <list>
                    <Term value="Mutex&lt;T&gt;" definition="Mutex&lt;T&gt; is a synchronization primitive provided in Rust that is used to enforce mutual exclusion, ensuring that only one thread can access the data it protects at a time." />
                    <Term value="lock" definition="The lock method of a Mutex is used to acquire the lock, blocking the current thread until it can obtain access to the data inside the mutex." />
                    <Term value="MutexGuard" definition="MutexGuard is a smart pointer returned by the lock method of Mutex, providing access to the mutex's data and automatically releasing the lock when it goes out of scope." />
                    <Term value="Deref" definition="Deref is a trait implemented by smart pointers such as MutexGuard to provide access to the data they point to by dereferencing." />
                    <Term value="Drop" definition="Drop is a trait in Rust that allows automatic cleanup of resources. For example, when a MutexGuard goes out of scope, its Drop implementation is called to release the lock on the mutex." />
                    <Term value="dropping" definition="Drop is a trait in Rust that allows automatic cleanup of resources. For example, when a MutexGuard goes out of scope, its Drop implementation is called to release the lock on the mutex." />
                  </list>
                </value>
              </entry>
              <entry key="1384085479">
                <value>
                  <list>
                    <Term value="Structs" definition="In programming, a Struct is a custom data type that groups related data together and can also define logic such as methods." />
                    <Term value="struct" definition="In programming, a Struct is a custom data type that groups related data together and can also define logic such as methods." />
                    <Term value="method" definition="In Rust, a Method is a function defined within the context of a struct, enum, or trait and is associated with its instance or type." />
                  </list>
                </value>
              </entry>
              <entry key="1399825717">
                <value>
                  <list>
                    <Term value="String Slices" definition="A string slice is a reference to part of a `String` or string literal, allowing efficient utilization without ownership transfer in Rust." />
                    <Term value="string slice" definition="A string slice is a reference to part of a `String` or string literal, allowing efficient utilization without ownership transfer in Rust." />
                    <Term value="string slices" definition="A string slice is a reference to part of a `String` or string literal, allowing efficient utilization without ownership transfer in Rust." />
                    <Term value="String" definition="In Rust, `String` is a growable, heap-allocated data structure used to represent text." />
                    <Term value="string" definition="In Rust, `String` is a growable, heap-allocated data structure used to represent text." />
                    <Term value="first_word function" definition="The `first_word` function in Rust is designed to retrieve the first word from a string or string slice by using efficient references and slices." />
                  </list>
                </value>
              </entry>
              <entry key="1412601441">
                <value>
                  <list>
                    <Term value="Vec" definition="In Rust, a Vec is a growable vector type that stores elements of the same type in a contiguous block of memory." />
                  </list>
                </value>
              </entry>
              <entry key="1425215109">
                <value>
                  <list>
                    <Term value="lifetime parameters" definition="In Rust, a lifetime parameter specifies the period during which a reference is valid and ensures memory safety by preventing dangling references." />
                    <Term value="lifetime parameter" definition="In Rust, a lifetime parameter specifies the period during which a reference is valid and ensures memory safety by preventing dangling references." />
                    <Term value="dangling reference" definition="A dangling reference occurs when a program attempts to access a reference to memory that has already been freed or is out of scope." />
                  </list>
                </value>
              </entry>
              <entry key="1435206826">
                <value>
                  <list>
                    <Term value="sort_by_key" definition="A standard library method in Rust defined on slices. It takes a closure that implements `FnMut`, which gets a reference to the current item in the slice and returns a value of type `K` that can be ordered, enabling sorting by a specific attribute in a slice of items." />
                    <Term value="FnMut" definition="A Rust trait that allows the closure to mutate its environment. Used in scenarios where closures need to be called multiple times and make modifications to their environment." />
                    <Term value="FnOnce" definition="A Rust trait for closures that can be called exactly once because they capture variables by value and these values cannot be accessed again after the closure is executed." />
                    <Term value="fn" definition="A Rust trait representing closures that can be called multiple times without mutating their environment or moving values out of it. It is the most restrictive among the `Fn`, `FnMut`, and `FnOnce` traits." />
                    <Term value="Fn" definition="A Rust trait representing closures that can be called multiple times without mutating their environment or moving values out of it. It is the most restrictive among the `Fn`, `FnMut`, and `FnOnce` traits." />
                  </list>
                </value>
              </entry>
              <entry key="1439756218">
                <value>
                  <list>
                    <Term value="Rc&lt;T&gt;" definition="In Rust, Rc&lt;T&gt; is a reference-counted smart pointer. It enables multiple ownership of the same data by keeping track of the number of references and automatically deallocates the data when the count reaches zero." />
                    <Term value="Rc::clone()" definition="Rc::clone() in Rust increments the reference count of a value wrapped within Rc&lt;T&gt; without deeply copying the data." />
                    <Term value="drop()" definition="drop() in Rust explicitly deallocates or removes a value from memory before it goes out of scope." />
                  </list>
                </value>
              </entry>
              <entry key="1443937835">
                <value>
                  <list>
                    <Term value="Extract Method Refactoring" definition="A technique in programming where duplicated segments of code are replaced with a single method or function to maintain code simplicity and reduce redundancy." />
                    <Term value="Refactor -&gt; Extract Method" definition="A feature in Integrated Development Environments (IDEs) that allows developers to move selected blocks of code into a new method or function for better code readability and maintainability." />
                  </list>
                </value>
              </entry>
              <entry key="1474234055">
                <value>
                  <list>
                    <Term value="io::Error" definition="A struct provided by the standard library in Rust to represent errors that may occur during IO operations." />
                    <Term value="io::ErrorKind" definition="An enum provided by the standard library in Rust that represents the different kinds of errors that might result from an IO operation." />
                    <Term value="ErrorKind::NotFound" definition="A variant of the io::ErrorKind enum in Rust that indicates a file being opened does not exist." />
                    <Term value="File::open" definition="A method in Rust's standard library used to open a file and returns a Result type." />
                    <Term value="File::create" definition="A method in Rust's standard library used to create a new file, returning a Result type." />
                    <Term value="unwrap_or_else" definition="A method in Rust provided by the Result&lt;T, E&gt; type that allows the programmer to provide a closure to handle the Err case, simplifying nested match expressions." />
                  </list>
                </value>
              </entry>
              <entry key="1485410654">
                <value>
                  <list>
                    <Term value="Propagating Errors" definition="In programming, propagating errors refers to returning an error from a function to the calling code so that the calling code can decide how to handle that error." />
                    <Term value="propagating errors" definition="In programming, propagating errors refers to returning an error from a function to the calling code so that the calling code can decide how to handle that error." />
                    <Term value="Result&lt;T, E&gt;" definition="In Rust, Result&lt;T, E&gt; is an enum used for error handling. It represents either success with a value of type T (Ok) or failure with an error of type E (Err)." />
                    <Term value="io::Error" definition="In Rust, io::Error is a type used to represent errors that can occur while performing input and output operations." />
                    <Term value="File::open" definition="In Rust, File::open is a function used to open a file and obtain a file handle. It returns a Result indicating success or failure." />
                    <Term value="read_to_string" definition="In Rust, read_to_string is a method used to read the contents of a file into a string. It returns a Result indicating success or failure." />
                  </list>
                </value>
              </entry>
              <entry key="1492647473">
                <value>
                  <list>
                    <Term value="floating-point numbers" definition="Numbers with decimal points, represented in Rust by the types f32 and f64." />
                    <Term value="Floating-point numbers" definition="Numbers with decimal points, represented in Rust by the types f32 and f64." />
                    <Term value="f32" definition="A 32-bit single-precision floating-point type in Rust, represented according to the IEEE-754 standard." />
                    <Term value="f64" definition="A 64-bit double-precision floating-point type in Rust, represented according to the IEEE-754 standard." />
                  </list>
                </value>
              </entry>
              <entry key="1493926514">
                <value>
                  <list>
                    <Term value="String" definition="A String in Rust can grow in size and its contents can change, allowing for dynamic modification and concatenation." />
                    <Term value="string" definition="A String in Rust can grow in size and its contents can change, allowing for dynamic modification and concatenation." />
                    <Term value="strings" definition="A String in Rust can grow in size and its contents can change, allowing for dynamic modification and concatenation." />
                    <Term value="push_str" definition="The push_str method in Rust appends a string slice to a String without taking ownership of the parameter." />
                    <Term value="push" definition="The push method in Rust adds a single character to a String." />
                    <Term value="+ operator" definition="In Rust, the + operator is used to concatenate Strings by taking ownership of the first string and appending a string slice of the second." />
                    <Term value="format! Macro" definition="The format! macro in Rust returns a formatted String without taking ownership of its parameters, useful for complex string concatenation." />
                    <Term value="deref coercion" definition="Deref coercion in Rust converts references, such as &amp;String to &amp;str, automatically when appropriate." />
                  </list>
                </value>
              </entry>
              <entry key="1494553809">
                <value>
                  <list>
                    <Term value="Generics" definition="Generics allow for the creation of code that can operate on different types while maintaining type safety." />
                    <Term value="generic" definition="Generics allow for the creation of code that can operate on different types while maintaining type safety." />
                    <Term value="generics" definition="Generics allow for the creation of code that can operate on different types while maintaining type safety." />
                    <Term value="monomorphization" definition="Monomorphization is the process of turning generic code into specific code by filling in the concrete types that are used during compilation." />
                    <Term value="Monomorphization" definition="Monomorphization is the process of turning generic code into specific code by filling in the concrete types that are used during compilation." />
                    <Term value="Option&lt;T&gt;" definition="In Rust, `Option&lt;T&gt;` is an enum used for optional values, which may either have a value of type `T` or be empty (`None`)." />
                  </list>
                </value>
              </entry>
              <entry key="1501351139">
                <value>
                  <list>
                    <Term value="Glob Operator" definition="In Rust, the glob operator (*) is used in a `use` statement to bring all public items defined in a particular path into the current scope." />
                    <Term value="glob operator" definition="In Rust, the glob operator (*) is used in a `use` statement to bring all public items defined in a particular path into the current scope." />
                  </list>
                </value>
              </entry>
              <entry key="1520360038">
                <value>
                  <list>
                    <Term value="mathematical operator" definition="Rust supports basic mathematical operations including addition (`+`), subtraction (`-`), multiplication (`*`), division (`/`), and remainder (`%`)." />
                  </list>
                </value>
              </entry>
              <entry key="1532293599">
                <value>
                  <list>
                    <Term value="Threads" definition="Features that run independent parts of a program simultaneously in a process." />
                    <Term value="threads" definition="Features that run independent parts of a program simultaneously in a process." />
                    <Term value="thread" definition="Features that run independent parts of a program simultaneously in a process." />
                    <Term value="threading" definition="Features that run independent parts of a program simultaneously in a process." />
                    <Term value="Race conditions" definition="A situation where threads are accessing data or resources in an inconsistent order." />
                    <Term value="Deadlocks" definition="A situation where two threads are waiting for each other to release resources, preventing both from continuing." />
                    <Term value="runtime" definition="Code included by the language in every binary to support language features; smaller runtimes result in smaller binaries but offer fewer features." />
                    <Term value="Runtime" definition="Code included by the language in every binary to support language features; smaller runtimes result in smaller binaries but offer fewer features." />
                    <Term value="runtimes" definition="Code included by the language in every binary to support language features; smaller runtimes result in smaller binaries but offer fewer features." />
                  </list>
                </value>
              </entry>
              <entry key="1540602084">
                <value>
                  <list>
                    <Term value="Structs" definition="A struct, or structure, is a custom data type in Rust that lets you name and package together multiple related values that form a meaningful group." />
                    <Term value="struct" definition="A struct, or structure, is a custom data type in Rust that lets you name and package together multiple related values that form a meaningful group." />
                    <Term value="structs" definition="A struct, or structure, is a custom data type in Rust that lets you name and package together multiple related values that form a meaningful group." />
                    <Term value="enums" definition="Enums in Rust are building blocks for creating new types, enabling programs to take advantage of compile-time type checking." />
                    <Term value="Enums" definition="Enums in Rust are building blocks for creating new types, enabling programs to take advantage of compile-time type checking." />
                  </list>
                </value>
              </entry>
              <entry key="1546402481">
                <value>
                  <list>
                    <Term value="dangling pointer" definition="A dangling pointer references a location in memory that may have been given to someone else, often caused by freeing memory while preserving a pointer to it." />
                    <Term value="Dangling References" definition="In Rust, a dangling reference is prevented by the compiler, ensuring that referenced data will not go out of scope before the reference does." />
                    <Term value="dangling references" definition="In Rust, a dangling reference is prevented by the compiler, ensuring that referenced data will not go out of scope before the reference does." />
                    <Term value="dangling reference" definition="In Rust, a dangling reference is prevented by the compiler, ensuring that referenced data will not go out of scope before the reference does." />
                    <Term value="lifetime" definition="In Rust, a lifetime specifies how long a reference to data is valid and prevents dangling references at compile time." />
                    <Term value="lifetimes" definition="In Rust, a lifetime specifies how long a reference to data is valid and prevents dangling references at compile time." />
                  </list>
                </value>
              </entry>
              <entry key="1547325545">
                <value>
                  <list>
                    <Term value="Ranges" definition="A `Range` is a type provided by Rust's standard library that generates all numbers in sequence starting from one number and ending before another number." />
                    <Term value="Range" definition="A `Range` is a type provided by Rust's standard library that generates all numbers in sequence starting from one number and ending before another number." />
                    <Term value="range" definition="A `Range` is a type provided by Rust's standard library that generates all numbers in sequence starting from one number and ending before another number." />
                    <Term value="rev" definition="`rev` is a method in Rust used to reverse the order of a range." />
                  </list>
                </value>
              </entry>
              <entry key="1560212004">
                <value>
                  <list>
                    <Term value="Integer" definition="A number without a fractional component. Examples in Rust include `i32` for signed integers and `u32` for unsigned integers with 32 bits of space." />
                    <Term value="integer" definition="A number without a fractional component. Examples in Rust include `i32` for signed integers and `u32` for unsigned integers with 32 bits of space." />
                    <Term value="signed integer" definition="An integer type that can represent both positive and negative numbers. In Rust, signed integers are prefixed with `i`, for example, `i32`." />
                    <Term value="unsigned integer" definition="An integer type that can only represent positive numbers. In Rust, unsigned integers are prefixed with `u`, for example, `u32`." />
                    <Term value="two's complement" definition="A representation used for storing signed numbers in binary, where the most significant bit represents the sign." />
                    <Term value="integer literals" definition="Different ways to write integer values in Rust, including decimal, hex, octal, binary, and byte (e.g., `0xff` for hex or `b'A'` for a byte literal)." />
                    <Term value="Integer Literals" definition="Different ways to write integer values in Rust, including decimal, hex, octal, binary, and byte (e.g., `0xff` for hex or `b'A'` for a byte literal)." />
                  </list>
                </value>
              </entry>
              <entry key="1561432353">
                <value>
                  <list>
                    <Term value="Struct" definition="A Struct in Rust is a custom data type that allows you to group related data together. It’s a way to manage related pieces of data as one." />
                    <Term value="structs" definition="A Struct in Rust is a custom data type that allows you to group related data together. It’s a way to manage related pieces of data as one." />
                  </list>
                </value>
              </entry>
              <entry key="1566817461">
                <value>
                  <list>
                    <Term value="thread::spawn" definition="A function in Rust that creates a new thread of execution and returns a JoinHandle struct." />
                    <Term value="JoinHandle" definition="A struct in Rust returned by thread::spawn, which allows the program to wait for the thread to finish using the join method." />
                    <Term value="Join" definition="A method on a JoinHandle in Rust that blocks the current thread until the associated thread finishes execution." />
                    <Term value="join" definition="A method on a JoinHandle in Rust that blocks the current thread until the associated thread finishes execution." />
                    <Term value="unwrap" definition="A method in Rust that extracts the result from an Option or Result, panicking if it contains None or Err." />
                  </list>
                </value>
              </entry>
              <entry key="1585635681">
                <value>
                  <list>
                    <Term value="SystemTime" definition="In Rust, `SystemTime` is a struct from the `std::time` module that represents system time, which can be used to get the current time or measure time durations." />
                    <Term value="UNIX_EPOCH" definition="In Rust, `UNIX_EPOCH` is a constant in the `std::time` module representing the starting point of Unix time, January 1, 1970 00:00:00 UTC." />
                  </list>
                </value>
              </entry>
              <entry key="1601634575">
                <value>
                  <list>
                    <Term value="Option&lt;T&gt;" definition="In Rust, the `Option&lt;T&gt;` enum is used to represent a value that may be either present (`Some(T)`) or absent (`None`)." />
                    <Term value="Null" definition="In programming, `null` is a value that indicates no value is present. Rust avoids null to enhance safety and uses `Option&lt;T&gt;` instead." />
                    <Term value="null" definition="In programming, `null` is a value that indicates no value is present. Rust avoids null to enhance safety and uses `Option&lt;T&gt;` instead." />
                    <Term value="nulls" definition="In programming, `null` is a value that indicates no value is present. Rust avoids null to enhance safety and uses `Option&lt;T&gt;` instead." />
                    <Term value="some" definition="`Some` is a variant of the `Option&lt;T&gt;` enum in Rust, representing a value that is present." />
                    <Term value="Some" definition="`Some` is a variant of the `Option&lt;T&gt;` enum in Rust, representing a value that is present." />
                    <Term value="None" definition="`None` is a variant of the `Option&lt;T&gt;` enum in Rust, representing the absence of a value." />
                    <Term value="generic type parameter" definition="In Rust, a generic type parameter, such as `&lt;T&gt;`, allows the definition of types, functions, or structs that can operate on multiple types." />
                  </list>
                </value>
              </entry>
              <entry key="1608065847">
                <value>
                  <list>
                    <Term value="Closures" definition="A closure is a function or a block of code that captures the variables from its surrounding environment." />
                    <Term value="closures" definition="A closure is a function or a block of code that captures the variables from its surrounding environment." />
                    <Term value="closure" definition="A closure is a function or a block of code that captures the variables from its surrounding environment." />
                    <Term value="filter method" definition="The filter method is an iterator adaptor that takes a closure, which returns a Boolean to determine whether an item should be included in the resulting iterator." />
                  </list>
                </value>
              </entry>
              <entry key="1612359634">
                <value>
                  <list>
                    <Term value="Parameters" definition="In programming, a parameter is a special variable in a function’s signature that is used to accept values, known as arguments, when the function is called." />
                    <Term value="parameters" definition="In programming, a parameter is a special variable in a function’s signature that is used to accept values, known as arguments, when the function is called." />
                    <Term value="parameter" definition="In programming, a parameter is a special variable in a function’s signature that is used to accept values, known as arguments, when the function is called." />
                    <Term value="arguments" definition="In programming, an argument is a concrete value provided as input to a function’s parameter when calling the function." />
                    <Term value="argument" definition="In programming, an argument is a concrete value provided as input to a function’s parameter when calling the function." />
                    <Term value="type annotations" definition="In Rust, type annotation is the explicit declaration of the data type of a variable, including parameters in function signatures." />
                  </list>
                </value>
              </entry>
              <entry key="1635707965">
                <value>
                  <list>
                    <Term value="String Literals" definition="String literals in Rust are stored inside the binary and are immutable because they are of type `&amp;str`, which is an immutable reference to a slice." />
                    <Term value="string literals" definition="String literals in Rust are stored inside the binary and are immutable because they are of type `&amp;str`, which is an immutable reference to a slice." />
                    <Term value="&amp;str" definition="In Rust, `&amp;str` is a slice pointing to a specific point in the binary and represents an immutable reference to a string." />
                  </list>
                </value>
              </entry>
              <entry key="1638014521">
                <value>
                  <list>
                    <Term value="Attribute-like macros" definition="Attribute-like macros in Rust allow you to create new attributes and apply them to various items such as functions, structs, and enums to generate code." />
                    <Term value="attribute-like macro" definition="Attribute-like macros in Rust allow you to create new attributes and apply them to various items such as functions, structs, and enums to generate code." />
                    <Term value="attribute-like macros" definition="Attribute-like macros in Rust allow you to create new attributes and apply them to various items such as functions, structs, and enums to generate code." />
                    <Term value="proc_macro_attribute" definition="`proc_macro_attribute` in Rust is used to define attribute-like procedural macros that process and generate code based on attributes." />
                    <Term value="TokenStream" definition="A `TokenStream` in Rust represents the input and output of procedural macros and contains the code to be processed or generated as tokens." />
                  </list>
                </value>
              </entry>
              <entry key="1640360030">
                <value>
                  <list>
                    <Term value="for loop" definition="In Rust, a for loop is a concise and safer way to iterate over each item in a collection, avoiding issues like array index out of bounds." />
                  </list>
                </value>
              </entry>
              <entry key="1659063000">
                <value>
                  <list>
                    <Term value="Hashmap" definition="In Rust, a HashMap is a collection that stores key-value pairs. It is similar to a dictionary in other programming languages, providing fast retrieval of values by key." />
                    <Term value="HashMap" definition="In Rust, a HashMap is a collection that stores key-value pairs. It is similar to a dictionary in other programming languages, providing fast retrieval of values by key." />
                    <Term value="entry()" definition="The entry() method in Rust's HashMap API allows you to access or modify the value associated with a key. If the key does not exist, it can initialize a new entry." />
                    <Term value="or_insert()" definition="The or_insert() method in Rust's HashMap API is used to insert a value only if the key does not already have an associated value." />
                  </list>
                </value>
              </entry>
              <entry key="1659920785">
                <value>
                  <list>
                    <Term value="Mutex&lt;T&gt;" definition="Mutex&lt;T&gt; provides interior mutability, allowing mutation of contents even when the Mutex&lt;T&gt; is immutable, but comes with risks such as potential deadlocks." />
                    <Term value="Arc&lt;T&gt;" definition="Arc&lt;T&gt; is used in conjunction with Mutex&lt;T&gt; to enable thread-safe shared ownership of data, allowing mutation of contents inside an Arc&lt;T&gt;." />
                    <Term value="RefCell&lt;T&gt;" definition="RefCell&lt;T&gt; provides interior mutability, enabling mutation of contents even when the RefCell&lt;T&gt; is immutable." />
                    <Term value="Rc&lt;T&gt;" definition="Rc&lt;T&gt; is used for shared ownership of data, but it comes with risks like reference cycles that can cause memory leaks." />
                    <Term value="deadlocks" definition="Deadlocks occur when two threads are waiting for each other to release resources, causing both to wait indefinitely." />
                    <Term value="deadlock" definition="Deadlocks occur when two threads are waiting for each other to release resources, causing both to wait indefinitely." />
                  </list>
                </value>
              </entry>
              <entry key="1672793953">
                <value>
                  <list>
                    <Term value="Vec Trait" definition="In Rust, a Vec trait allows you to work with functionality associated with vectors, such as updating or manipulating vector elements." />
                    <Term value="AppendBar" definition="AppendBar is a trait to be implemented for a vector of strings, adding 'Bar' to the vector of strings." />
                  </list>
                </value>
              </entry>
              <entry key="1679218659">
                <value>
                  <list>
                    <Term value="assert!" definition="In Rust, `assert!` is a macro used to ensure that a condition evaluates to true at runtime. If the condition is false, the program will panic." />
                  </list>
                </value>
              </entry>
              <entry key="1693829952">
                <value>
                  <list>
                    <Term value="Structs" definition="In Rust, a Struct is a custom data type that groups related data together and assigns names to these data pieces, called fields." />
                    <Term value="struct" definition="In Rust, a Struct is a custom data type that groups related data together and assigns names to these data pieces, called fields." />
                    <Term value="structs" definition="In Rust, a Struct is a custom data type that groups related data together and assigns names to these data pieces, called fields." />
                    <Term value="dot notation" definition="In Rust, dot notation is used to access or modify specific fields of a struct instance." />
                  </list>
                </value>
              </entry>
              <entry key="1696297721">
                <value>
                  <list>
                    <Term value="immutable references" definition="A reference in Rust that does not allow modification of the borrowed value." />
                    <Term value="mutable reference" definition="A reference in Rust that allows modification of the borrowed value." />
                  </list>
                </value>
              </entry>
              <entry key="1711068755">
                <value>
                  <list>
                    <Term value="tuple" definition="A tuple is a collection of values grouped together, often of different types, and is used as a single compound value." />
                    <Term value="Clone" definition="Clone in Rust explicitly creates a deep copy of data, duplicating its contents." />
                    <Term value="clone" definition="Clone in Rust explicitly creates a deep copy of data, duplicating its contents." />
                  </list>
                </value>
              </entry>
              <entry key="1715928876">
                <value>
                  <list>
                    <Term value="? Operator" definition="In Rust, the ? operator is a shortcut for propagating errors. It simplifies error handling by returning the value inside Ok if it’s successful, or returning the error value early if it encounters an Err." />
                    <Term value="? operator" definition="In Rust, the ? operator is a shortcut for propagating errors. It simplifies error handling by returning the value inside Ok if it’s successful, or returning the error value early if it encounters an Err." />
                    <Term value="fs::read_to_string" definition="In Rust, the fs::read_to_string function reads the entire contents of a file into a String and returns it, providing a convenient way to handle common file reading operations." />
                  </list>
                </value>
              </entry>
              <entry key="1740475492">
                <value>
                  <list>
                    <Term value="trait" definition="A Trait in Rust is a collection of methods defined for an unknown type, used to define shared behavior." />
                    <Term value="Default Implementations" definition="Default implementation in Rust refers to providing a method implementation within a Trait itself, which can be used by types implementing that Trait without overriding the method." />
                    <Term value="Default implementations" definition="Default implementation in Rust refers to providing a method implementation within a Trait itself, which can be used by types implementing that Trait without overriding the method." />
                    <Term value="default implementation" definition="Default implementation in Rust refers to providing a method implementation within a Trait itself, which can be used by types implementing that Trait without overriding the method." />
                    <Term value="overriding" definition="In Rust, override refers to redefining a method in a type that provides its own implementation for a Trait's method, replacing the default implementation if one exists." />
                  </list>
                </value>
              </entry>
              <entry key="1747181674">
                <value>
                  <list>
                    <Term value="Trait Bounds" definition="Trait bounds in Rust allow methods to be implemented conditionally for types that satisfy specific traits." />
                    <Term value="trait bounds" definition="Trait bounds in Rust allow methods to be implemented conditionally for types that satisfy specific traits." />
                    <Term value="generic type parameters" definition="Generic type parameters in Rust enable defining structures, functions, or methods that can operate on multiple different types." />
                    <Term value="blanket implementations" definition="Blanket implementations in Rust are implementations of a trait for any type that satisfies certain trait bounds." />
                    <Term value="blanket implementation" definition="Blanket implementations in Rust are implementations of a trait for any type that satisfies certain trait bounds." />
                    <Term value="Blanket implementations" definition="Blanket implementations in Rust are implementations of a trait for any type that satisfies certain trait bounds." />
                  </list>
                </value>
              </entry>
              <entry key="1750337792">
                <value>
                  <list>
                    <Term value="crates" definition="In Rust, a crate is a compilation unit or package that allows you to organize your Rust code." />
                    <Term value="crate" definition="In Rust, a crate is a compilation unit or package that allows you to organize your Rust code." />
                    <Term value="modules" definition="In Rust, a module is a way to organize related code under a single namespace, and it helps in maintaining the visibility and reusability of code." />
                    <Term value="module" definition="In Rust, a module is a way to organize related code under a single namespace, and it helps in maintaining the visibility and reusability of code." />
                    <Term value="Module" definition="In Rust, a module is a way to organize related code under a single namespace, and it helps in maintaining the visibility and reusability of code." />
                    <Term value="Modules" definition="In Rust, a module is a way to organize related code under a single namespace, and it helps in maintaining the visibility and reusability of code." />
                    <Term value="relative paths" definition="Relative paths in Rust start from a parent or sibling module and are used to refer to items relative to the current module." />
                    <Term value="`use` statement" definition="In Rust, a `use` statement is used to bring a path into the current scope, providing a shorter way to refer to items." />
                    <Term value="`pub` keyword" definition="In Rust, the `pub` keyword is used to make module definitions public, allowing them to be accessed from outside their own module." />
                  </list>
                </value>
              </entry>
              <entry key="1765755974">
                <value>
                  <list>
                    <Term value="fn add_exclamation" definition="A function that mutates its argument in the provided context." />
                    <Term value="mutable reference" definition="A reference to a variable that allows modification of the variable's value." />
                  </list>
                </value>
              </entry>
              <entry key="1791335948">
                <value>
                  <list>
                    <Term value="Procedural Macro" definition="Procedural macros are a way to create custom derive functionality that allows developers to automatically generate code for a trait on annotated Rust types." />
                    <Term value="procedural macro" definition="Procedural macros are a way to create custom derive functionality that allows developers to automatically generate code for a trait on annotated Rust types." />
                    <Term value="procedural macros" definition="Procedural macros are a way to create custom derive functionality that allows developers to automatically generate code for a trait on annotated Rust types." />
                    <Term value="TokenStream" definition="TokenStream is a data structure provided by Rust that represents a sequence of tokens or symbols in the code, often used in procedural macros to manipulate Rust code." />
                    <Term value="syn" definition="The syn crate is used to parse Rust code from a string into a data structure that procedural macros can operate on." />
                    <Term value="quote" definition="The quote crate allows Rust code to be generated from data structures and facilitates templating-like functionality in procedural macros." />
                    <Term value="HelloMacro trait" definition="The HelloMacro trait is an example trait used in a procedural macro that provides a function to print the name of the annotated type prefixed by a hello message." />
                  </list>
                </value>
              </entry>
              <entry key="1793779890">
                <value>
                  <list>
                    <Term value="Integration Tests" definition="A test that evaluates how different parts of a program work together, commonly placed in the *tests* directory and compiled as separate crates in Rust." />
                    <Term value="integration tests" definition="A test that evaluates how different parts of a program work together, commonly placed in the *tests* directory and compiled as separate crates in Rust." />
                    <Term value="integration test" definition="A test that evaluates how different parts of a program work together, commonly placed in the *tests* directory and compiled as separate crates in Rust." />
                    <Term value="crate" definition="A package of Rust code. Each integration test file in the *tests* directory is compiled as its own separate crate." />
                    <Term value="crates" definition="A package of Rust code. Each integration test file in the *tests* directory is compiled as its own separate crate." />
                    <Term value="Crates" definition="A package of Rust code. Each integration test file in the *tests* directory is compiled as its own separate crate." />
                    <Term value="Modules" definition="A way to organize code in Rust. A module can be used to separate functionalities into different files, including in the *tests* directory." />
                    <Term value="modules" definition="A way to organize code in Rust. A module can be used to separate functionalities into different files, including in the *tests* directory." />
                    <Term value="module" definition="A way to organize code in Rust. A module can be used to separate functionalities into different files, including in the *tests* directory." />
                    <Term value="Binary Crates" definition="A type of crate in Rust that contains executable code and typically has a file named *src/main.rs*." />
                    <Term value="binary crate" definition="A type of crate in Rust that contains executable code and typically has a file named *src/main.rs*." />
                    <Term value="binary crates" definition="A type of crate in Rust that contains executable code and typically has a file named *src/main.rs*." />
                    <Term value="library crates" definition="A type of crate in Rust that contains reusable code, generally structured with a *src/lib.rs* file, allowing integration tests to import its functionality." />
                    <Term value="library crate" definition="A type of crate in Rust that contains reusable code, generally structured with a *src/lib.rs* file, allowing integration tests to import its functionality." />
                  </list>
                </value>
              </entry>
              <entry key="1813800728">
                <value>
                  <list>
                    <Term value="Associated Functions" definition="Functions defined within 'impl' blocks that don’t take 'self' as a parameter and are associated with the struct, but are not methods." />
                    <Term value="associated functions" definition="Functions defined within 'impl' blocks that don’t take 'self' as a parameter and are associated with the struct, but are not methods." />
                    <Term value="Associated functions" definition="Functions defined within 'impl' blocks that don’t take 'self' as a parameter and are associated with the struct, but are not methods." />
                    <Term value="associated function" definition="Functions defined within 'impl' blocks that don’t take 'self' as a parameter and are associated with the struct, but are not methods." />
                  </list>
                </value>
              </entry>
              <entry key="1835671940">
                <value>
                  <list>
                    <Term value="FnOnce" definition="FnOnce applies to closures that can be called at least once and move captured values out of their body." />
                    <Term value="FnMut" definition="FnMut applies to closures that do not move captured values out of their body but might mutate the captured values." />
                    <Term value="Fn" definition="Fn applies to closures that do not move captured values out of their body and do not mutate captured values." />
                  </list>
                </value>
              </entry>
              <entry key="1839621434">
                <value>
                  <list>
                    <Term value="interior mutability" definition="In Rust, interior mutability is a design pattern that allows you to mutate data even when accessed through an immutable reference. This is often implemented using types like `std::cell::Cell` and `std::cell::RefCell`." />
                    <Term value="std::cell::Cell" definition="The `std::cell::Cell` type in Rust enables interior mutability by providing a simple container for values that can be set and retrieved even when the `Cell` itself is accessed immutably." />
                  </list>
                </value>
              </entry>
              <entry key="1856808445">
                <value>
                  <list>
                    <Term value="AsRef" definition="AsRef is a Rust trait that allows for cheap reference-to-reference conversions." />
                    <Term value="AsMut" definition="AsMut is a Rust trait that allows for cheap reference-to-reference conversions." />
                  </list>
                </value>
              </entry>
              <entry key="1861856979">
                <value>
                  <list>
                    <Term value="Closure" definition="A function or a reference to a function along with a referencing environment of non-local variables that the closure can access." />
                    <Term value="closure" definition="A function or a reference to a function along with a referencing environment of non-local variables that the closure can access." />
                  </list>
                </value>
              </entry>
              <entry key="1867339050">
                <value>
                  <list>
                    <Term value="String::new" definition="`String::new` is a function used to create a new, empty String in Rust." />
                    <Term value="to_string" definition="`to_string` is a method available on types implementing the `Display` trait, including string literals, to create a `String` in Rust." />
                    <Term value="String::from" definition="`String::from` is a function used to create a `String` from a string literal in Rust." />
                    <Term value="UTF-8" definition="UTF-8 is an encoding format used for strings in Rust, allowing inclusion of properly encoded data, such as greetings in different languages." />
                  </list>
                </value>
              </entry>
              <entry key="1868862068">
                <value>
                  <list>
                    <Term value="Engine" definition="A module containing a vector of Workers, responsible for running and maintaining the log for the workers." />
                    <Term value="engine" definition="A module containing a vector of Workers, responsible for running and maintaining the log for the workers." />
                    <Term value="Workers" definition="A struct that performs work and writes to the log during the execution of the Engine." />
                    <Term value="Worker" definition="A struct that performs work and writes to the log during the execution of the Engine." />
                    <Term value="workers" definition="A struct that performs work and writes to the log during the execution of the Engine." />
                    <Term value="worker" definition="A struct that performs work and writes to the log during the execution of the Engine." />
                    <Term value="log" definition="A vector of Strings in the Engine module where workers write their outputs." />
                    <Term value="interior mutability" definition="A Rust feature that allows for mutable access to an immutable value using constructs like RefCell." />
                    <Term value="RefCell" definition="A Rust type used to achieve interior mutability, enabling temporary mutable access to immutable data." />
                  </list>
                </value>
              </entry>
              <entry key="1874946640">
                <value>
                  <list>
                    <Term value="Matches" definition="In Rust, 'match' is a control structure that allows you to branch code execution based on pattern matching." />
                    <Term value="match" definition="In Rust, 'match' is a control structure that allows you to branch code execution based on pattern matching." />
                    <Term value="matched" definition="In Rust, 'match' is a control structure that allows you to branch code execution based on pattern matching." />
                    <Term value="Option&lt;T&gt;" definition="In Rust, 'Option&lt;T&gt;' is an enum used to represent a value that may be either 'Some(T)', containing a value of type 'T', or 'None', indicating no value." />
                    <Term value="None" definition="In Rust, 'None' is a variant of the 'Option&lt;T&gt;' enum that represents the absence of a value." />
                    <Term value="Some" definition="In Rust, 'Some' is a variant of the 'Option&lt;T&gt;' enum that wraps and represents a value of type 'T'." />
                  </list>
                </value>
              </entry>
              <entry key="1885200339">
                <value>
                  <list>
                    <Term value="mpsc::channel" definition="In Rust, `mpsc::channel` creates a multiple producer, single consumer channel. It allows multiple sending ends to produce values and a single receiving end to consume those values." />
                    <Term value="tx and rx" definition="In Rust, `tx` and `rx` are abbreviations for transmitter and receiver, respectively, traditionally used to refer to the sending and receiving ends of a channel." />
                  </list>
                </value>
              </entry>
              <entry key="1890423352">
                <value>
                  <list>
                    <Term value="as keyword" definition="The 'as' keyword in Rust is used to provide a new local name, or alias, for a type when bringing it into scope." />
                    <Term value="IoResult" definition="IoResult is an alias for the std::io::Result type, created using the 'as' keyword in Rust." />
                  </list>
                </value>
              </entry>
              <entry key="1896801178">
                <value>
                  <list>
                    <Term value="Scope" definition="In programming, a scope is the range within a program for which an item is valid." />
                    <Term value="scope" definition="In programming, a scope is the range within a program for which an item is valid." />
                    <Term value="scopes" definition="In programming, a scope is the range within a program for which an item is valid." />
                    <Term value="Variable Scope" definition="Variable Scope refers to the range within a program where a variable is declared and valid." />
                  </list>
                </value>
              </entry>
              <entry key="1900601419">
                <value>
                  <list>
                    <Term value="capitalize_first" definition="A function that capitalizes the first character of a string and returns it, e.g., input 'hello' returns 'Hello'." />
                    <Term value="char" definition="A primitive data type in Rust representing a single Unicode character." />
                    <Term value="as_str" definition="A method in Rust used to convert a variable, like a char, into a string slice." />
                    <Term value="collect" definition="A general and powerful Rust method used to transform iterators into collections like vectors or strings." />
                    <Term value="Collect" definition="A general and powerful Rust method used to transform iterators into collections like vectors or strings." />
                  </list>
                </value>
              </entry>
              <entry key="1930688254">
                <value>
                  <list>
                    <Term value="String" definition="In Rust, `String` is a heap-allocated, mutable string type that can store a variable amount of text not known at compile time." />
                    <Term value="string" definition="In Rust, `String` is a heap-allocated, mutable string type that can store a variable amount of text not known at compile time." />
                    <Term value="String::from" definition="`String::from` is a function in Rust that creates a `String` from a string literal." />
                    <Term value="drop" definition="`drop` is a special function in Rust called automatically when a variable goes out of scope to clean up resources, such as deallocating memory." />
                    <Term value="Resource Acquisition Is Initialization (RAII)" definition="RAII is a pattern where resources are tied to the lifetime of objects, and deallocation is handled automatically at the object's destruction, used in Rust and C++." />
                  </list>
                </value>
              </entry>
              <entry key="1942191630">
                <value>
                  <list>
                    <Term value="associated function" definition="An associated function in Rust, like `summer` in the example, is a function tied to a struct or enum that helps create instances when some fields are private." />
                  </list>
                </value>
              </entry>
              <entry key="1951157774">
                <value>
                  <list>
                    <Term value="ownership" definition="In Rust, ownership is a set of rules that governs how memory is managed and ensures memory safety at compile time. The owner of a data automatically cleans up the data when going out of scope." />
                    <Term value="Ownership" definition="In Rust, ownership is a set of rules that governs how memory is managed and ensures memory safety at compile time. The owner of a data automatically cleans up the data when going out of scope." />
                    <Term value="borrowing" definition="Borrowing in Rust refers to the concept where references to data can be used without taking ownership of the data." />
                    <Term value="slices" definition="Slices in Rust allow you to reference a contiguous sequence of elements in a collection rather than the whole collection." />
                  </list>
                </value>
              </entry>
              <entry key="1960065281">
                <value>
                  <list>
                    <Term value="Rc&lt;T&gt;" definition="A Rust smart pointer type that provides shared ownership of a value. Multiple references can be created using clone, but it is not thread-safe." />
                    <Term value="Mutex&lt;T&gt;" definition="A synchronization primitive used to protect shared data from being accessed by multiple threads concurrently in Rust." />
                  </list>
                </value>
              </entry>
              <entry key="1988667765">
                <value>
                  <list>
                    <Term value="Lifetime Annotations" definition="A lifetime annotation in Rust is used to specify the lifespan of references to ensure they are valid as long as they are needed, preventing dangling references." />
                    <Term value="lifetime annotation" definition="A lifetime annotation in Rust is used to specify the lifespan of references to ensure they are valid as long as they are needed, preventing dangling references." />
                    <Term value="Struct" definition="In Rust, a struct is a custom data type that groups together related data using named fields." />
                    <Term value="structs" definition="In Rust, a struct is a custom data type that groups together related data using named fields." />
                    <Term value="struct" definition="In Rust, a struct is a custom data type that groups together related data using named fields." />
                    <Term value="ImportantExcerpt" definition="A struct in the Rust example that holds a reference to part of a string slice, requiring a lifetime annotation to ensure validity of the reference." />
                    <Term value="string slice" definition="A string slice in Rust is a reference to a portion of a string, allowing functions to operate on segments of strings without copying." />
                  </list>
                </value>
              </entry>
              <entry key="1990277744">
                <value>
                  <list>
                    <Term value="Mutex&lt;T&gt;" definition="In Rust, `Mutex&lt;T&gt;` is a synchronization primitive that provides mutual exclusion by locking access to a shared resource." />
                    <Term value="thread::spawn" definition="In Rust, `thread::spawn` is used to create a new thread of execution to run a closure." />
                    <Term value="lock" definition="The `lock` method in Rust is used on a Mutex to acquire a lock, blocking the current thread until it is able to do so." />
                    <Term value="move" definition="In Rust, the `move` keyword is used to force closure to take ownership of the values it uses." />
                    <Term value="moves" definition="In Rust, the `move` keyword is used to force closure to take ownership of the values it uses." />
                    <Term value="moved" definition="In Rust, the `move` keyword is used to force closure to take ownership of the values it uses." />
                    <Term value="join" definition="In Rust, the `join` method waits for a thread to finish execution and allows retrieving its return value." />
                  </list>
                </value>
              </entry>
              <entry key="1994784250">
                <value>
                  <list>
                    <Term value="Method" definition="Methods are similar to functions but are defined within the context of a struct, enum, or trait object, with their first parameter always being 'self', representing the instance of the struct the method is being called on." />
                    <Term value="Methods" definition="Methods are similar to functions but are defined within the context of a struct, enum, or trait object, with their first parameter always being 'self', representing the instance of the struct the method is being called on." />
                    <Term value="methods" definition="Methods are similar to functions but are defined within the context of a struct, enum, or trait object, with their first parameter always being 'self', representing the instance of the struct the method is being called on." />
                    <Term value="method" definition="Methods are similar to functions but are defined within the context of a struct, enum, or trait object, with their first parameter always being 'self', representing the instance of the struct the method is being called on." />
                    <Term value="struct" definition="In Rust, a struct is a custom data type that is used to group related data together." />
                    <Term value="enum" definition="In Rust, an enum is a type that represents data which can be one of several variants." />
                    <Term value="trait object" definition="A trait object in Rust is a way to perform dynamic dispatch by referring to an instance of a type that implements a trait." />
                  </list>
                </value>
              </entry>
              <entry key="1997020243">
                <value>
                  <list>
                    <Term value="Vec&lt;i32&gt;" definition="In Rust, `Vec&lt;i32&gt;` denotes a vector containing elements of the `i32` type." />
                  </list>
                </value>
              </entry>
              <entry key="2000427279">
                <value>
                  <list>
                    <Term value="Trait" definition="In Rust, a trait defines shared behavior that can be implemented on types." />
                    <Term value="trait" definition="In Rust, a trait defines shared behavior that can be implemented on types." />
                    <Term value="traits" definition="In Rust, a trait defines shared behavior that can be implemented on types." />
                    <Term value="orphan rule" definition="A Rust rule ensuring that a trait can only be implemented on a type if either the trait or the type is local to the crate, preventing conflicts and coherence issues." />
                  </list>
                </value>
              </entry>
              <entry key="2005165709">
                <value>
                  <list>
                    <Term value="generics in struct definitions" definition="In Rust, generics in struct definitions allow you to define a struct that operates on one or more types using angle brackets (&lt;&gt;). For example, a struct `Point&lt;T&gt;` can hold fields of type `T` for flexibility." />
                    <Term value="type mismatch error" definition="Occurs in Rust when the types of variables in a generic struct do not match the declared generic type, as seen when assigning an integer to `x` and a float to `y` in `Point&lt;T&gt;`." />
                    <Term value="multiple generic type parameters" definition="Allows each field of a struct, such as `Point&lt;T, U&gt;`, to use different types by specifying multiple type parameters in the struct definition." />
                  </list>
                </value>
              </entry>
              <entry key="2006086218">
                <value>
                  <list>
                    <Term value="Trait" definition="A trait in Rust is a way to group method signatures together, defining a set of behaviors necessary to accomplish a specific purpose." />
                    <Term value="trait" definition="A trait in Rust is a way to group method signatures together, defining a set of behaviors necessary to accomplish a specific purpose." />
                  </list>
                </value>
              </entry>
              <entry key="2026098198">
                <value>
                  <list>
                    <Term value="crate root" definition="The starting point for the compiler when compiling a crate, typically _src/lib.rs_ for a library crate or _src/main.rs_ for a binary crate." />
                    <Term value="privacy rules" definition="In Rust, code within a module is private by default and must be explicitly made public using the `pub` keyword to access it from outside the module." />
                  </list>
                </value>
              </entry>
              <entry key="2029461687">
                <value>
                  <list>
                    <Term value="enum" definition="In Rust, an `enum` is a type that can be one of several variants, each possibly containing data." />
                    <Term value="matching arm" definition="In a `match` expression in Rust, arms consist of a pattern and some code, separated by the `=&gt;` operator, which gets executed when the pattern matches the value." />
                    <Term value="match arm" definition="In a `match` expression in Rust, arms consist of a pattern and some code, separated by the `=&gt;` operator, which gets executed when the pattern matches the value." />
                  </list>
                </value>
              </entry>
              <entry key="2039994672">
                <value>
                  <list>
                    <Term value="Option&lt;&amp;V&gt;" definition="`Option&lt;&amp;V&gt;` is the return type of the `get` method in a HashMap that represents either `Some(&amp;value)` when the key exists or `None` when it doesn't." />
                  </list>
                </value>
              </entry>
              <entry key="2041311681">
                <value>
                  <list>
                    <Term value="Integration Tests" definition="In Rust, integration tests are entirely external to the library. They test whether many parts of the library work together correctly by using the library's public API, but cannot access private functions or components." />
                    <Term value="integration tests" definition="In Rust, integration tests are entirely external to the library. They test whether many parts of the library work together correctly by using the library's public API, but cannot access private functions or components." />
                    <Term value="integration test" definition="In Rust, integration tests are entirely external to the library. They test whether many parts of the library work together correctly by using the library's public API, but cannot access private functions or components." />
                    <Term value="cargo test" definition="In Rust, the `cargo test` command is used to compile and run tests. It treats the *tests* directory specially, compiling its files only during test runs and enabling selective test execution." />
                  </list>
                </value>
              </entry>
              <entry key="2059088948">
                <value>
                  <list>
                    <Term value="ownership" definition="In Rust, ownership is a concept where each value in the program has a variable that is its owner, and ownership can be transferred between variables." />
                    <Term value="tuple" definition="In Rust, a tuple is a general way of grouping a fixed set of values of varying types into a single compound value." />
                    <Term value="len()" definition="In Rust, the len() method returns the length of a String." />
                    <Term value="references" definition="In Rust, references allow you to refer to some value without taking ownership of it." />
                  </list>
                </value>
              </entry>
              <entry key="2059988272">
                <value>
                  <list>
                    <Term value="thread::spawn" definition="In Rust, `thread::spawn` is used to create a new thread to execute a closure or a function." />
                    <Term value="mpsc::channel" definition="In Rust, `mpsc::channel` creates a multiple producer, single consumer communication channel." />
                    <Term value="Moving" definition="In Rust, `move` is a keyword used to transfer the ownership of variables into a closure." />
                    <Term value="move" definition="In Rust, `move` is a keyword used to transfer the ownership of variables into a closure." />
                  </list>
                </value>
              </entry>
              <entry key="2067250722">
                <value>
                  <list>
                    <Term value="Dangling References" definition="A dangling reference occurs when a program references data that has been deallocated or gone out of scope." />
                    <Term value="dangling references" definition="A dangling reference occurs when a program references data that has been deallocated or gone out of scope." />
                    <Term value="scope" definition="In Rust, scope determines the lifetime of a variable. Once a variable goes out of scope, it is deallocated." />
                    <Term value="compile-time error" definition="A compile-time error occurs when the code violates language rules, preventing the program from being compiled." />
                  </list>
                </value>
              </entry>
              <entry key="2085492098">
                <value>
                  <list>
                    <Term value="lifetime annotation" definition="Lifetime annotations in Rust are used to specify how long references are valid and ensure that the program does not contain dangling references." />
                    <Term value="Structs with References" definition="In Rust, structs can hold references, but they require lifetime annotations to define the scope of those references." />
                  </list>
                </value>
              </entry>
              <entry key="2130917215">
                <value>
                  <list>
                    <Term value="Constant" definition="Constants are always immutable variables, declared with the keyword 'const' rather than 'let', and must always be annotated." />
                    <Term value="constants" definition="Constants are always immutable variables, declared with the keyword 'const' rather than 'let', and must always be annotated." />
                    <Term value="Constants" definition="Constants are always immutable variables, declared with the keyword 'const' rather than 'let', and must always be annotated." />
                  </list>
                </value>
              </entry>
              <entry key="2142854428">
                <value>
                  <list>
                    <Term value="Ownership" definition="Rust's unique feature that enables memory safety guarantees without needing a garbage collector by managing memory through a set of rules checked at compile time." />
                    <Term value="ownership" definition="Rust's unique feature that enables memory safety guarantees without needing a garbage collector by managing memory through a set of rules checked at compile time." />
                    <Term value="Stack" definition="A part of memory where values are stored in order and removed in reverse order, referred to as 'last in, first out'." />
                    <Term value="stack" definition="A part of memory where values are stored in order and removed in reverse order, referred to as 'last in, first out'." />
                    <Term value="Heap" definition="A less organized part of memory where data with an unknown or variable size at compile time is stored, with access via pointers." />
                    <Term value="heap" definition="A less organized part of memory where data with an unknown or variable size at compile time is stored, with access via pointers." />
                    <Term value="allocating on the heap" definition="The process of requesting memory space on the heap, finding an empty spot, marking it in use, and returning its pointer." />
                    <Term value="ownership rules" definition="Rules governing Rust's memory management, including each value having one owner, only one owner at a time, and values being dropped when their owner goes out of scope." />
                  </list>
                </value>
              </entry>
            </map>
          </value>
        </entry>
      </map>
    </terms>
    <termsVersions>
      <map>
        <entry key="en" value="50" />
      </map>
    </termsVersions>
  </component>
</project>